# Anna v0.10.1 - Event Architecture Readiness Assessment

## Executive Summary

**Status**: ðŸŸ¡ **75% Ready** - Strong foundation, requires privilege model correction

Anna has achieved architectural coherence with capabilities, integrity, and doctor systems forming a disciplined spine. The transition to event-driven intelligence requires **one critical fix** and two enhancements.

---

## Verification of Requirements

### âœ… Requirement 1: Integrity Checks Are Reusable

**Status**: PASS

The `IntegrityWatchdog` exposes:
```rust
pub fn sweep(&self) -> Result<Vec<IntegrityAlert>>
```

Individual domain checks are available as private methods:
- `check_binaries()` â†’ binary integrity
- `check_systemd_units()` â†’ unit file presence
- `check_directories()` â†’ directory permissions
- `check_capabilities()` â†’ module dependencies
- `check_groups()` â†’ user/group existence
- `check_disk_space()` â†’ storage thresholds

**For event engine**: Each method returns `Vec<IntegrityAlert>` and can be called independently.

**Action Required**: Expose domain-specific check methods as public:
```rust
// Current (private)
fn check_capabilities(&self) -> Result<Vec<IntegrityAlert>>

// Needed for events
pub fn check_domain(&self, domain: &str) -> Result<Vec<IntegrityAlert>> {
    match domain {
        "packages" => self.check_capabilities(),
        "config" => self.check_config_drift(),  // TODO
        "devices" => self.check_devices(),      // TODO
        "network" => self.check_network(),      // TODO
        _ => Ok(vec![])
    }
}
```

**Effort**: 1 hour

---

### âœ… Requirement 2: Capability Registry Declares Dependencies

**Status**: PASS

CAPABILITIES.toml fully declares:
- **deps.required** and **deps.optional** (packages, commands)
- **checks** (commands, files, evidence)
- **degraded** (reason, action, impact)

Example:
```toml
[modules.sensors.deps.optional]
packages = ["lm_sensors"]
commands = ["sensors"]

[modules.sensors.checks]
commands = ["sensors -u"]
files = ["/sys/class/hwmon", "/sys/class/thermal"]
```

`CapabilityManager` parses this and computes Active/Degraded/Disabled states.

**For event engine**: When pacman hook fires "lm_sensors installed", trigger `doctor("packages")` which calls `CapabilityManager::check_all()` and detects sensors â†’ Active.

**Action Required**: None - ready as-is.

---

### âš ï¸ Requirement 3: Systemd Unit Runs as Root with Capabilities

**Status**: FAIL - Needs Correction

**Current unit** (`etc/systemd/annad.service`):
```ini
User=anna
Group=anna
CapabilityBoundingSet=
```

**Problem**: Runs as unprivileged user `anna`, cannot perform system setup operations.

**Expected**:
```ini
User=root
Group=root
CapabilityBoundingSet=CAP_DAC_READ_SEARCH CAP_SETUID CAP_SETGID CAP_SYS_ADMIN
```

**Impact**:
- âŒ Cannot create users/groups
- âŒ Cannot install packages
- âŒ Cannot modify systemd units
- âŒ Cannot set filesystem permissions

**Why This Matters**:
- `doctor.rs` needs root to run `useradd`, `chown`, `pacman`, `systemctl`
- `integrity.rs` needs `CAP_DAC_READ_SEARCH` to verify all files
- Event-driven repairs (e.g., "sensors package installed") need `CAP_SETUID` to run as different users

**Action Required**: Update systemd unit (see fix below)

**Effort**: 30 minutes

---

## Critical Fix: Privilege-Separated Systemd Unit

### New Unit File

```ini
[Unit]
Description=Anna v0.10.1 Pure Telemetry Observer Daemon
Documentation=https://github.com/anna-assistant/anna
After=network.target local-fs.target

[Service]
Type=simple

# Run as root for privileged operations
User=root
Group=root

# Capability Bounding Set
# CAP_DAC_READ_SEARCH  - Read any file for integrity checks
# CAP_SETUID           - Create/modify users
# CAP_SETGID           - Create/modify groups
# CAP_SYS_ADMIN        - Mount, systemctl operations (trim if not needed)
CapabilityBoundingSet=CAP_DAC_READ_SEARCH CAP_SETUID CAP_SETGID CAP_SYS_ADMIN

# Execution
ExecStart=/usr/local/bin/annad
Restart=on-failure
RestartSec=10
StandardOutput=journal
StandardError=journal

# Resource Limits
CPUQuota=5%
MemoryMax=80M
TasksMax=32

# Runtime Directory
RuntimeDirectory=anna
RuntimeDirectoryMode=0750

# Security Hardening
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=strict
ProtectHome=yes
ProtectKernelTunables=yes
ProtectKernelModules=yes
ProtectControlGroups=yes
RestrictNamespaces=yes
RestrictRealtime=yes
RestrictSUIDSGID=yes
LockPersonality=yes

# Writable Paths (minimal)
ReadWritePaths=/var/lib/anna /var/log/anna /run/anna /etc/systemd/system /var/lib/pacman /etc

# Restrict Sensitive Filesystems
ProtectKernelLogs=yes
PrivateDevices=no  # Need access to /dev for sensors

[Install]
WantedBy=multi-user.target
```

### Why This Design

1. **Root for Setup**: Doctor operations need root (useradd, pacman, systemctl)
2. **Capability Bounding**: Even as root, limited to 4 capabilities
3. **No New Privileges**: Cannot escalate further
4. **Strict Filesystem**: Only write to data/log/runtime + system config
5. **Kernel Protection**: Cannot modify kernel tunables or load modules

### Socket Permissions

With root daemon:
```bash
/run/anna/annad.sock  0660 root:anna
```

Users in `anna` group can connect to socket. RPC layer validates requests.

---

## Event Engine Integration Points

Once privilege model is corrected, event hooks can call:

### 1. Package Changes (pacman hook)

```bash
# /usr/share/libalpm/hooks/anna-notify.hook
[Trigger]
Type = Package
Operation = Install
Operation = Upgrade
Operation = Remove
Target = *

[Action]
When = PostTransaction
Exec = /usr/bin/systemd-notify --pid=$MAINPID WATCHDOG=trigger:packages
```

In annad:
```rust
// Receive systemd notify
if event == "packages" {
    let alerts = integrity_watchdog.check_domain("packages")?;
    if !alerts.is_empty() && policy.auto_repair("packages") {
        doctor_apply.repair_domain("packages", &alerts)?;
    }
}
```

### 2. Config Drift (inotify)

```rust
// Watch /etc for CREATE|DELETE|MOVE|CLOSE_WRITE
inotify.watch("/etc", IN_CLOSE_WRITE)?;

// On event
if path_in_allowlist(&changed_path) {
    enqueue_job(Event::ConfigChange(changed_path), 300ms_coalesce);
}

// Job handler
let alerts = integrity_watchdog.check_domain("config")?;
```

### 3. Device Changes (udev)

```rust
// Monitor udev events
udev.monitor()?;

// On add/remove
if device.subsystem == "usb" || device.subsystem == "block" {
    enqueue_job(Event::DeviceChange(device), 300ms_coalesce);
}
```

### 4. Network Changes (netlink)

```rust
// Subscribe to RTNETLINK
netlink.subscribe(RTNLGRP_LINK | RTNLGRP_IPV4_IFADDR)?;

// On event
enqueue_job(Event::NetworkChange, 300ms_coalesce);
```

---

## Remaining Work for Event Architecture

### Phase 1: Privilege Correction (2 hours)

1. âœ… Update `etc/systemd/annad.service` with root + capabilities
2. âœ… Update `doctor.rs` to handle socket permissions (0660 root:anna)
3. âœ… Test installer creates anna group and adds current user
4. âœ… Verify annactl (user) can connect to socket

### Phase 2: Domain-Specific Checks (4 hours)

1. âœ… Expose `IntegrityWatchdog::check_domain(domain)` public API
2. âœ… Add `check_config_drift()` - inotify + hash cache
3. âœ… Add `check_devices()` - udev device list
4. âœ… Add `check_network()` - netlink link state

### Phase 3: Event Sources (8 hours)

1. âœ… Implement pacman hook â†’ systemd-notify
2. âœ… Implement inotify watcher for /etc
3. âœ… Implement udev monitor
4. âœ… Implement netlink subscriber

### Phase 4: Job Queue & Coalescing (6 hours)

1. âœ… Event queue with 300ms gather window
2. âœ… Per-domain 30s cooldown
3. âœ… Job metadata (cause list for explainability)
4. âœ… Policy engine (auto-repair vs alert-only)

### Phase 5: Adaptive Logging (2 hours)

1. âœ… `/var/log/anna/adaptive.log` - structured event log
2. âœ… Schema: `{timestamp, domain, cause[], action, result}`
3. âœ… Rotation policy (1MB, 5 files)

**Total Effort**: ~22 hours across 5 phases

---

## Architectural Coherence Check

### âœ… The Spine (Capabilities + Integrity + Doctor)

```
Event â†’ Queue â†’ Coalesce â†’ Doctor(domain) â†’ Repair(issues) â†’ Log
                              â†“                   â†“
                         Capability Check    Fix Commands
                              â†“                   â†“
                         Active/Degraded    Success/Fail
```

**Current state**:
- Capability check: âœ… Working (CAPABILITIES.toml + CapabilityManager)
- Integrity check: âœ… Working (IntegrityWatchdog)
- Doctor apply: âœ… Working (but needs root daemon)
- Event sources: âŒ Not implemented
- Job queue: âŒ Not implemented
- Policy engine: âŒ Not implemented

**After fixes**:
- All components present
- Event â†’ repair loop complete
- Fully autonomous within policy bounds

---

## Decision Points

### Q1: Should annad drop privileges after setup?

**Recommendation**: No.

Event-driven repairs require ongoing root access (package installs, unit reloads). The capability bounding set + hardening flags provide sufficient isolation.

Alternative: Split into two services:
- `annad-observer` (user anna) - telemetry only
- `annad-doctor` (root) - repairs only, socket-activated

**Verdict**: Single root daemon with tight capabilities is simpler and sufficient for v0.10.1.

### Q2: How to handle package installs on non-Arch?

**Recommendation**: Distro abstraction layer.

```rust
trait PackageManager {
    fn install(&self, packages: &[&str]) -> Result<()>;
    fn is_installed(&self, package: &str) -> bool;
}

struct PacmanManager;
struct AptManager;
struct DnfManager;

// Auto-detect in doctor.rs
let pm: Box<dyn PackageManager> = detect_package_manager()?;
pm.install(&["lm_sensors"])?;
```

**Verdict**: Implement for v0.10.2; for v0.10.1, Arch-only is acceptable.

### Q3: RPC authentication - how?

**Recommendation**: Unix socket with group check.

```rust
// In RPC handler
let peer_cred = socket.peer_cred()?;
let groups = get_user_groups(peer_cred.uid)?;

if !groups.contains("anna") {
    return Err("Not in anna group");
}
```

**Verdict**: Implement in Phase 1.

---

## Test Strategy for Event Engine

### Unit Tests

```rust
#[test]
fn test_package_event_triggers_doctor() {
    let event = Event::PackageChange("lm_sensors".into());
    let queue = EventQueue::new();
    queue.enqueue(event);

    // Wait for coalesce
    sleep(Duration::from_millis(350));

    let jobs = queue.drain();
    assert_eq!(jobs.len(), 1);
    assert_eq!(jobs[0].domain, "packages");
}

#[test]
fn test_cooldown_prevents_spam() {
    let queue = EventQueue::new();
    queue.enqueue(Event::PackageChange("foo".into()));
    queue.enqueue(Event::PackageChange("bar".into()));

    // Both should coalesce into one job
    sleep(Duration::from_millis(350));
    let jobs = queue.drain();
    assert_eq!(jobs.len(), 1);

    // New event within cooldown should be ignored
    queue.enqueue(Event::PackageChange("baz".into()));
    sleep(Duration::from_millis(350));
    let jobs = queue.drain();
    assert_eq!(jobs.len(), 0); // Still in 30s cooldown
}
```

### Integration Tests

```bash
# Simulate pacman hook
echo "trigger:packages" | systemd-notify --pid=$(pidof annad)

# Verify doctor ran
journalctl -u annad -n 20 | grep "Running doctor for domain: packages"

# Verify capability updated
annactl capabilities | grep sensors | grep ACTIVE
```

---

## Conclusion

Anna v0.10.1 has **achieved architectural maturity** with three solid foundations:

1. **Capabilities** - Knows what it can do
2. **Integrity** - Knows when something breaks
3. **Doctor** - Knows how to fix it

**One critical fix required**: Update systemd unit to run as root with capability bounding.

**Then**: Event engine can hook into `doctor(domain)` and `repair(issue)`, creating a closed loop from observation to adaptive response.

Anna is ready to stop being a passive observer and become a **living system analyst** with semantic awareness of change.

---

**Next Immediate Action**: Update `etc/systemd/annad.service` and test privilege-separated operation.

**Timeline**:
- Phase 1 (privilege fix): 2 hours
- Phase 2-5 (event engine): 20 hours
- **Total**: One focused development sprint

**Risk**: Low - architecture is sound, implementation is additive, no breaking changes to existing telemetry.

---

*Assessment Date: 2025-10-31*
*Version: v0.10.1*
*Readiness: 75% - Excellent foundation, one critical fix, then ready for event intelligence*
