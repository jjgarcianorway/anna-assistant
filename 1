// cmd/annad/src/main.rs

mod journal;
mod plan;

use anyhow::Result;
use std::{env, fs, path::PathBuf, thread, time::Duration};
use tracing::{error, info};
use tracing_subscriber::{fmt, EnvFilter};

fn ensure_dirs() -> Result<(PathBuf, PathBuf)> {
    // System-wide state root; the installer runs annad as a system service.
    let root = PathBuf::from("/var/lib/anna");
    let plans = root.join("plans"); // plans/<id>/{apply.sh, rollback.sh, README.txt}
    fs::create_dir_all(&plans)?;
    Ok((root, plans))
}

fn hb_interval() -> Duration {
    let secs = env::var("ANNA_HEARTBEAT_SECS")
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(60);
    Duration::from_secs(secs)
}

#[tokio::main]
async fn main() -> Result<()> {
    // Use journald's timestamp; keep target+level for clarity.
    fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .with_target(true)
        .with_level(true)
        .without_time() // rely on journald time; annactl formats consistently
        .init();

    let (_root, plans_root) = ensure_dirs()?;

    info!(target: "annad", "starting {}", env!("CARGO_PKG_VERSION"));

    // Heartbeat loop (configurable via ANNA_HEARTBEAT_SECS)
    let hb = tokio::spawn(async move {
        loop {
            tokio::time::sleep(hb_interval()).await;
            info!(target: "annad", "heartbeat");
        }
    });

    // Journald follower: on repeated SSH failures, emit a reversible plan
    let plans_root_clone = plans_root.clone();
    let jf = thread::spawn(move || {
        let _ = journal::follow_journal(|| {
            match plan::suggest_harden_ssh(&plans_root_clone) {
                Ok(pp) => info!(target: "annad", "suggested plan at {}", pp.dir.display()),
                Err(e) => error!(target: "annad", "plan write failed: {e:?}"),
            }
        });
    });

    // Keep the process alive; heartbeat never returns. Join the helper thread on shutdown.
    let _ = tokio::try_join!(hb);
    let _ = jf.join();

    Ok(())
}
