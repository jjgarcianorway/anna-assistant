//! Package management configuration detection
//!
//! Detects package management configuration:
//! - pacman.conf options and settings
//! - Mirrorlist age and configuration
//! - AUR helper presence

use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;
use std::time::SystemTime;

/// Package management configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageManagementInfo {
    /// Parallel downloads enabled in pacman.conf
    pub parallel_downloads: Option<u8>,
    /// Color output enabled
    pub color_enabled: bool,
    /// VerbosePkgLists enabled
    pub verbose_pkg_lists: bool,
    /// ILoveCandy (easter egg progress bar)
    pub ilove_candy: bool,
    /// Mirrorlist file age in days
    pub mirrorlist_age_days: Option<u64>,
    /// Number of mirrors in mirrorlist
    pub mirror_count: usize,
    /// Mirrorlist uses reflector
    pub uses_reflector: bool,
    /// AUR helper installed (yay, paru, etc.)
    pub aur_helper: Option<String>,
    /// Pacman cache directory size in MB
    pub cache_size_mb: Option<u64>,
    /// Number of packages in cache
    pub cache_package_count: Option<usize>,
}

impl PackageManagementInfo {
    /// Detect package management configuration
    pub fn detect() -> Self {
        let (parallel_downloads, color_enabled, verbose_pkg_lists, ilove_candy) =
            parse_pacman_conf();
        let (mirrorlist_age_days, mirror_count, uses_reflector) = analyze_mirrorlist();
        let aur_helper = detect_aur_helper();
        let (cache_size_mb, cache_package_count) = analyze_pacman_cache();

        Self {
            parallel_downloads,
            color_enabled,
            verbose_pkg_lists,
            ilove_candy,
            mirrorlist_age_days,
            mirror_count,
            uses_reflector,
            aur_helper,
            cache_size_mb,
            cache_package_count,
        }
    }
}

/// Parse pacman.conf for configuration options
fn parse_pacman_conf() -> (Option<u8>, bool, bool, bool) {
    let pacman_conf_path = "/etc/pacman.conf";

    let content = match fs::read_to_string(pacman_conf_path) {
        Ok(c) => c,
        Err(_) => return (None, false, false, false),
    };

    let mut parallel_downloads = None;
    let mut color_enabled = false;
    let mut verbose_pkg_lists = false;
    let mut ilove_candy = false;

    for line in content.lines() {
        let line = line.trim();

        // Skip comments and empty lines
        if line.starts_with('#') || line.is_empty() {
            continue;
        }

        // Check for ParallelDownloads
        if line.starts_with("ParallelDownloads") {
            if let Some(value) = line.split('=').nth(1) {
                if let Ok(num) = value.trim().parse::<u8>() {
                    parallel_downloads = Some(num);
                }
            }
        }

        // Check for Color
        if line == "Color" {
            color_enabled = true;
        }

        // Check for VerbosePkgLists
        if line == "VerbosePkgLists" {
            verbose_pkg_lists = true;
        }

        // Check for ILoveCandy
        if line == "ILoveCandy" {
            ilove_candy = true;
        }
    }

    (
        parallel_downloads,
        color_enabled,
        verbose_pkg_lists,
        ilove_candy,
    )
}

/// Analyze mirrorlist
fn analyze_mirrorlist() -> (Option<u64>, usize, bool) {
    let mirrorlist_path = "/etc/pacman.d/mirrorlist";

    // Get file age
    let age_days = if let Ok(metadata) = fs::metadata(mirrorlist_path) {
        if let Ok(modified) = metadata.modified() {
            if let Ok(duration) = SystemTime::now().duration_since(modified) {
                Some(duration.as_secs() / 86400) // Convert to days
            } else {
                None
            }
        } else {
            None
        }
    } else {
        None
    };

    // Count mirrors and check for reflector
    let mut mirror_count = 0;
    let mut uses_reflector = false;

    if let Ok(content) = fs::read_to_string(mirrorlist_path) {
        for line in content.lines() {
            let line = line.trim();

            // Count active mirror servers
            if line.starts_with("Server = ") {
                mirror_count += 1;
            }

            // Check if generated by reflector
            if line.contains("reflector") || line.contains("Reflector") {
                uses_reflector = true;
            }
        }
    }

    (age_days, mirror_count, uses_reflector)
}

/// Detect AUR helper
fn detect_aur_helper() -> Option<String> {
    let aur_helpers = vec![
        "yay", "paru", "pikaur", "aurman", "trizen", "pacaur", "aura",
    ];

    for helper in aur_helpers {
        if let Ok(output) = std::process::Command::new("which").arg(helper).output() {
            if output.status.success() {
                // Try to get version
                if let Ok(version_output) =
                    std::process::Command::new(helper).arg("--version").output()
                {
                    if version_output.status.success() {
                        let version_str = String::from_utf8_lossy(&version_output.stdout);
                        let first_line = version_str.lines().next().unwrap_or(helper);
                        return Some(first_line.to_string());
                    }
                }
                return Some(helper.to_string());
            }
        }
    }

    None
}

/// Analyze pacman cache
fn analyze_pacman_cache() -> (Option<u64>, Option<usize>) {
    let cache_dir = Path::new("/var/cache/pacman/pkg");

    if !cache_dir.exists() {
        return (None, None);
    }

    let mut total_size = 0u64;
    let mut package_count = 0usize;

    if let Ok(entries) = fs::read_dir(cache_dir) {
        for entry in entries.flatten() {
            if let Ok(metadata) = entry.metadata() {
                if metadata.is_file() {
                    total_size += metadata.len();
                    package_count += 1;
                }
            }
        }
    }

    let size_mb = if total_size > 0 {
        Some(total_size / 1024 / 1024) // Convert to MB
    } else {
        None
    };

    let count = if package_count > 0 {
        Some(package_count)
    } else {
        None
    };

    (size_mb, count)
}
