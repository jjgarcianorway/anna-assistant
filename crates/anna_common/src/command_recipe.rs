//! Command Recipe System - Beta.90
//!
//! This module defines the core data structures for Anna's command recipe system,
//! which transforms user questions into validated, executable command sequences.
//!
//! Architecture:
//! - Recipes are JSON structures that describe what to run and how to validate it
//! - Templates provide pre-built, tested recipes for common operations
//! - Planner LLM generates recipes from user questions + docs + telemetry
//! - Critic LLM validates recipes against docs and safety rules
//! - Runtime validation checks actual output against expected patterns

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// A command recipe - the fundamental unit of executable knowledge
///
/// Each recipe represents a single step in answering a user's question.
/// It includes not just the command to run, but also:
/// - Safety classification
/// - Expected output patterns for validation
/// - Documentation sources that justify the command
/// - Rollback/restore instructions for write operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommandRecipe {
    /// Unique identifier for this recipe step
    pub id: String,

    /// The actual shell command to execute
    pub command: String,

    /// Safety category for execution decision
    pub category: CommandCategory,

    /// Safety level assessment
    pub safety_level: SafetyLevel,

    /// Whether to capture stdout/stderr
    pub capture_output: bool,

    /// Runtime validation rules
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expected_validation: Option<OutputValidation>,

    /// Human-readable explanation of what this step does
    pub explanation: String,

    /// Arch Wiki or doc URLs that justify this command
    #[serde(default)]
    pub doc_sources: Vec<String>,

    /// For write operations: how to restore previous state
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rollback_command: Option<String>,

    /// Template ID if this was generated from a template
    #[serde(skip_serializing_if = "Option::is_none")]
    pub template_id: Option<String>,

    /// Template parameters if used
    #[serde(default)]
    pub template_params: HashMap<String, String>,
}

/// Command safety categories - determines auto-execution policy
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum CommandCategory {
    /// Pure read operations (ls, cat, grep, swapon --show, nvidia-smi)
    ReadOnly,

    /// Modifies user files but not system state
    UserWrite,

    /// Modifies system state (package install, service control)
    SystemWrite,

    /// Dangerous operations requiring extra confirmation
    Dangerous,
}

/// Safety level assessment
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SafetyLevel {
    /// Known safe, can auto-execute
    Safe,

    /// Requires user confirmation
    NeedsConfirmation,

    /// Blocked - should never execute
    Blocked,
}

/// Output validation rules - checks that command behaved as expected
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutputValidation {
    /// Expected exit code (usually 0)
    pub exit_code: i32,

    /// Regex that stdout must match (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stdout_must_match: Option<String>,

    /// Regex that stdout must NOT match (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stdout_must_not_match: Option<String>,

    /// Regex that stderr must match (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub stderr_must_match: Option<String>,

    /// Human-readable description of what validation checks
    pub validation_description: String,
}

/// A complete recipe - sequence of steps to answer a question
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Recipe {
    /// Question this recipe answers
    pub question: String,

    /// Sequential steps to execute
    pub steps: Vec<CommandRecipe>,

    /// Overall safety assessment
    pub overall_safety: SafetyLevel,

    /// Whether all steps are read-only
    pub all_read_only: bool,

    /// Arch Wiki pages consulted
    #[serde(default)]
    pub wiki_sources: Vec<String>,

    /// Summary of what this recipe will do
    pub summary: String,

    /// Generated by which model
    #[serde(skip_serializing_if = "Option::is_none")]
    pub generated_by: Option<String>,

    /// Critic validation result
    #[serde(skip_serializing_if = "Option::is_none")]
    pub critic_approval: Option<CriticResult>,
}

/// Result of critic LLM validation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CriticResult {
    /// Whether critic approved the recipe
    pub approved: bool,

    /// Critic's reasoning
    pub reasoning: String,

    /// Issues found (if any)
    #[serde(default)]
    pub issues: Vec<String>,

    /// Suggested corrections (if rejected)
    #[serde(default)]
    pub corrections: Vec<String>,
}

/// Execution result for a single recipe step
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StepResult {
    /// Step ID
    pub step_id: String,

    /// Exit code
    pub exit_code: i32,

    /// Captured stdout
    pub stdout: String,

    /// Captured stderr
    pub stderr: String,

    /// Whether validation passed
    pub validation_passed: bool,

    /// Validation failure reason (if any)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub validation_failure: Option<String>,

    /// Execution time in milliseconds
    pub execution_time_ms: u64,
}

/// Complete recipe execution result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecipeResult {
    /// Original question
    pub question: String,

    /// Results for each step
    pub step_results: Vec<StepResult>,

    /// Overall success
    pub success: bool,

    /// Final answer/summary
    pub answer: String,

    /// Total execution time
    pub total_time_ms: u64,
}

impl CommandRecipe {
    /// Check if this recipe step is safe to auto-execute
    pub fn is_auto_executable(&self) -> bool {
        self.category == CommandCategory::ReadOnly && self.safety_level == SafetyLevel::Safe
    }

    /// Validate command against allowlist/denylist
    pub fn validate_against_policy(&self, policy: &SafetyPolicy) -> Result<(), String> {
        let cmd_parts: Vec<&str> = self.command.split_whitespace().collect();
        if cmd_parts.is_empty() {
            return Err("Empty command".to_string());
        }

        let base_cmd = cmd_parts[0];

        // Check denylist first
        if policy.denied_commands.contains(&base_cmd.to_string()) {
            return Err(format!("Command '{}' is explicitly denied", base_cmd));
        }

        // Check for dangerous patterns
        for pattern in &policy.dangerous_patterns {
            if self.command.contains(pattern) {
                return Err(format!("Command contains dangerous pattern: '{}'", pattern));
            }
        }

        // For write operations, ensure allowlist compliance
        if matches!(
            self.category,
            CommandCategory::SystemWrite | CommandCategory::Dangerous
        ) {
            if !policy.allowed_system_commands.is_empty()
                && !policy
                    .allowed_system_commands
                    .contains(&base_cmd.to_string())
            {
                return Err(format!(
                    "System write command '{}' not in allowlist",
                    base_cmd
                ));
            }
        }

        Ok(())
    }
}

/// Safety policy - defines what commands are allowed/denied
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyPolicy {
    /// Commands that are always blocked
    pub denied_commands: Vec<String>,

    /// System commands that are explicitly allowed
    pub allowed_system_commands: Vec<String>,

    /// Dangerous patterns to detect in commands
    pub dangerous_patterns: Vec<String>,
}

impl Default for SafetyPolicy {
    fn default() -> Self {
        Self {
            denied_commands: vec![
                "rm".to_string(),
                "mkfs".to_string(),
                "dd".to_string(),
                "fdisk".to_string(),
                "parted".to_string(),
                "wipefs".to_string(),
                "shred".to_string(),
                ":(){:|:&};:".to_string(), // fork bomb
            ],
            allowed_system_commands: vec![
                "pacman".to_string(),
                "systemctl".to_string(),
                "swapon".to_string(),
                "swapoff".to_string(),
            ],
            dangerous_patterns: vec![
                "rm -rf /".to_string(),
                "chmod 777".to_string(),
                "chown -R".to_string(),
                "> /dev/sd".to_string(),
                "curl | sh".to_string(),
                "wget | sh".to_string(),
            ],
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_read_only_is_auto_executable() {
        let recipe = CommandRecipe {
            id: "test".to_string(),
            command: "swapon --show".to_string(),
            category: CommandCategory::ReadOnly,
            safety_level: SafetyLevel::Safe,
            capture_output: true,
            expected_validation: None,
            explanation: "Check swap".to_string(),
            doc_sources: vec![],
            rollback_command: None,
            template_id: None,
            template_params: HashMap::new(),
        };

        assert!(recipe.is_auto_executable());
    }

    #[test]
    fn test_deny_dangerous_command() {
        let recipe = CommandRecipe {
            id: "test".to_string(),
            command: "rm -rf /".to_string(),
            category: CommandCategory::Dangerous,
            safety_level: SafetyLevel::Blocked,
            capture_output: false,
            expected_validation: None,
            explanation: "Bad".to_string(),
            doc_sources: vec![],
            rollback_command: None,
            template_id: None,
            template_params: HashMap::new(),
        };

        let policy = SafetyPolicy::default();
        assert!(recipe.validate_against_policy(&policy).is_err());
    }
}
