//! Planner Core - LLM-driven command planning
//!
//! v6.41.0: The Planner receives user intent + telemetry and uses the LLM
//! to generate system-specific commands that will answer the question.
//!
//! v6.42.0: Real LLM integration with JSON schemas and fallback planning.
//!
//! This replaces hardcoded handlers with dynamic planning.

use crate::llm_client::{LlmClient, LlmError};
use crate::tool_inventory::ToolInventory;
use crate::execution_safety::{classify_command_risk, classify_command_domain, determine_execution_mode, PlanSummary, RiskLevel};
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

/// User intent classification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Intent {
    /// Goal type (Inspect, Diagnose, List, Check)
    pub goal: GoalType,

    /// Domain (packages, hardware, audio, GUI, filesystem, etc.)
    pub domain: DomainType,

    /// Constraints (path, count, specific features)
    pub constraints: Vec<Constraint>,

    /// Original query text
    pub query: String,
}

/// Goal types for user queries
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GoalType {
    /// Inspect system state ("do I have X?")
    Inspect,

    /// Diagnose issues ("is Y configured correctly?")
    Diagnose,

    /// List items ("show me Z")
    List,

    /// Check capabilities ("does my system support X?")
    Check,
}

/// Domain types for queries
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DomainType {
    /// Package management (installed packages, games, apps)
    Packages,

    /// Hardware (CPU, GPU, RAM, disk)
    Hardware,

    /// Audio system (PipeWire, PulseAudio, ALSA)
    Audio,

    /// GUI (DE, WM, display servers)
    Gui,

    /// Filesystem (disk space, directories)
    Filesystem,

    /// Services (systemd, daemons)
    Services,

    /// Network (connectivity, interfaces)
    Network,
}

/// Query constraints
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Constraint {
    /// Path constraint (e.g., "/home")
    Path(String),

    /// Count limit (e.g., "top 10")
    Count(usize),

    /// Feature name (e.g., "SSE", "AVX")
    Feature(String),

    /// Category (e.g., "games", "file managers")
    Category(String),
}

/// Command plan generated by LLM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommandPlan {
    /// Ordered list of shell commands to run
    pub commands: Vec<PlannedCommand>,

    /// Safety classification
    pub safety_level: SafetyLevel,

    /// Fallback options if tools are missing
    pub fallbacks: Vec<PlannedCommand>,

    /// Expected output shape
    pub expected_output: String,

    /// LLM reasoning for this plan
    pub reasoning: String,

    // v6.43.0: Approval flow metadata
    /// Human-readable description of what the user wants to achieve
    pub goal_description: Option<String>,

    /// Assumptions made by the planner
    pub assumptions: Vec<String>,

    /// Estimated confidence that this plan will satisfy the request (0.0-1.0)
    pub confidence: f32,
}

/// A single planned command
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlannedCommand {
    /// Command to execute
    pub command: String,

    /// Arguments
    pub args: Vec<String>,

    /// Expected purpose ("check for steam package")
    pub purpose: String,

    /// Required tools that must exist
    pub requires_tools: Vec<String>,

    // v6.43.0: Step-level approval metadata
    /// Step-specific risk level
    pub risk_level: StepRiskLevel,

    /// Whether this step writes files
    pub writes_files: bool,

    /// Whether this step requires root/sudo
    pub requires_root: bool,

    /// What "success" looks like for this step
    pub expected_outcome: Option<String>,

    /// What to check in the output to confirm success
    pub validation_hint: Option<String>,
}

/// Risk level for individual command steps (v6.43.0)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum StepRiskLevel {
    /// Read-only operation, no side effects
    ReadOnly,

    /// Low risk (creates cache, writes logs)
    Low,

    /// Medium risk (modifies config, requires user data)
    Medium,

    /// High risk (deletes data, system-wide changes)
    High,
}

/// Safety level for commands
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SafetyLevel {
    /// Read-only, completely safe (grep, ls, pacman -Q)
    ReadOnly,

    /// May write logs or cache, but no system changes
    MinimalWrite,

    /// Risky operations (package install, file deletion)
    Risky,
}

impl CommandPlan {
    /// Compute plan summary for v6.50.0 execution safety
    ///
    /// Analyzes all commands in the plan and determines:
    /// - Overall risk level (Safe/Moderate/High)
    /// - Execution mode (PlanOnly/ConfirmRequired)
    /// - Domains involved
    /// - Whether backups will be created
    pub fn compute_plan_summary(&self, is_interactive: bool) -> PlanSummary {
        let mut max_risk = RiskLevel::Safe;
        let mut domains = HashSet::new();
        let will_create_backups = self.commands.iter().any(|cmd| {
            cmd.command.contains("backup") || cmd.purpose.to_lowercase().contains("backup")
        });

        // Analyze each command to determine risk
        for cmd in &self.commands {
            let full_command = format!("{} {}", cmd.command, cmd.args.join(" "));
            let risk = classify_command_risk(&full_command, &cmd.purpose);

            if risk > max_risk {
                max_risk = risk;
            }

            let domain = classify_command_domain(&full_command);
            domains.insert(domain);
        }

        let execution_mode = determine_execution_mode(&max_risk, is_interactive);

        let description = self.goal_description.clone()
            .unwrap_or_else(|| format!("Execute {} command(s)", self.commands.len()));

        PlanSummary {
            description,
            risk_level: max_risk,
            domains: domains.into_iter().collect(),
            command_count: self.commands.len(),
            will_create_backups,
            execution_mode,
        }
    }
}

/// Planner interaction result (v6.43.0)
///
/// Represents the outcome of a planning attempt - either a ready plan
/// or a need for more information from the user.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PlannerInteraction {
    /// Planner has enough information and produced a plan
    PlanReady {
        plan: CommandPlan,
    },

    /// Planner needs clarification before it can produce a plan
    NeedMoreInfo {
        /// Questions to ask the user (numbered list)
        questions: Vec<String>,

        /// Context to pass back when user answers
        context: serde_json::Value,
    },

    /// Planner determined the query cannot be handled
    CannotHandle {
        reason: String,
    },
}

/// Interpret user query into structured intent
pub fn interpret_intent(query: &str) -> Intent {
    let query_lower = query.to_lowercase();

    // Determine goal type
    let goal = if query_lower.contains("do i have") || query_lower.contains("is") {
        GoalType::Inspect
    } else if query_lower.contains("show") || query_lower.contains("list") || query_lower.contains("what") {
        GoalType::List
    } else if query_lower.contains("does") || query_lower.contains("can") {
        GoalType::Check
    } else if query_lower.contains("why") || query_lower.contains("problem") {
        GoalType::Diagnose
    } else {
        GoalType::Inspect // Default
    };

    // Determine domain
    let domain = if query_lower.contains("game") || query_lower.contains("package")
        || query_lower.contains("app") || query_lower.contains("file manager")
        || query_lower.contains("browser") {
        DomainType::Packages
    } else if query_lower.contains("cpu") || query_lower.contains("gpu")
        || query_lower.contains("ram") || query_lower.contains("memory")
        || query_lower.contains("vram") {
        DomainType::Hardware
    } else if query_lower.contains("sound") || query_lower.contains("audio") {
        DomainType::Audio
    } else if query_lower.contains("de") || query_lower.contains("wm")
        || query_lower.contains("desktop") || query_lower.contains("window manager") {
        DomainType::Gui
    } else if query_lower.contains("disk") || query_lower.contains("folder")
        || query_lower.contains("space") || query_lower.contains("directory") {
        DomainType::Filesystem
    } else if query_lower.contains("service") || query_lower.contains("systemd") {
        DomainType::Services
    } else if query_lower.contains("network") || query_lower.contains("wifi") {
        DomainType::Network
    } else {
        DomainType::Packages // Default
    };

    // Extract constraints
    let mut constraints = Vec::new();

    // Path constraint
    if let Some(pos) = query_lower.find("in /") {
        let path_start = pos + 3;
        let path_end = query[path_start..].find(' ').map(|p| path_start + p).unwrap_or(query.len());
        constraints.push(Constraint::Path(query[path_start..path_end].to_string()));
    } else if query_lower.contains("home") || query_lower.contains("$home") {
        constraints.push(Constraint::Path("$HOME".to_string()));
    }

    // Count constraint (top N, biggest N)
    if let Some(num) = extract_number_from_query(&query_lower) {
        constraints.push(Constraint::Count(num));
    }

    // Feature constraint (SSE, AVX, etc.)
    for feature in &["sse", "sse2", "sse3", "sse4", "avx", "avx2", "avx-512"] {
        if query_lower.contains(feature) {
            constraints.push(Constraint::Feature(feature.to_string()));
        }
    }

    // Category constraint
    if query_lower.contains("game") {
        constraints.push(Constraint::Category("games".to_string()));
    } else if query_lower.contains("file manager") {
        constraints.push(Constraint::Category("file_managers".to_string()));
    } else if query_lower.contains("browser") {
        constraints.push(Constraint::Category("browsers".to_string()));
    }

    Intent {
        goal,
        domain,
        constraints,
        query: query.to_string(),
    }
}

/// Extract number from query (e.g., "top 10" -> 10)
fn extract_number_from_query(query: &str) -> Option<usize> {
    let words: Vec<&str> = query.split_whitespace().collect();
    for (i, word) in words.iter().enumerate() {
        if (*word == "top" || *word == "biggest" || *word == "largest") && i + 1 < words.len() {
            if let Ok(num) = words[i + 1].parse::<usize>() {
                return Some(num);
            }
        }
    }
    None
}

/// Build LLM prompt for command planning
pub fn build_planner_prompt(intent: &Intent, telemetry_summary: &str, available_tools: &[String]) -> String {
    let mut prompt = format!(
        "# Command Planning Task\n\n\
        User query: \"{}\"\n\n\
        ## Interpreted Intent\n\
        Goal: {:?}\n\
        Domain: {:?}\n",
        intent.query, intent.goal, intent.domain
    );

    if !intent.constraints.is_empty() {
        prompt.push_str("\nConstraints:\n");
        for constraint in &intent.constraints {
            prompt.push_str(&format!("  - {:?}\n", constraint));
        }
    }

    prompt.push_str(&format!(
        "\n## System Context\n{}\n\n\
        ## Available Tools\n\
        Your system has these package managers and tools:\n",
        telemetry_summary
    ));

    for tool in available_tools {
        prompt.push_str(&format!("  - {}\n", tool));
    }

    prompt.push_str(
        "\n## Your Task\n\
        Generate a list of shell commands that will answer the user's question on THIS SPECIFIC SYSTEM.\n\
        \n\
        Requirements:\n\
        1. Commands must be read-only (no package installs, no file deletions)\n\
        2. Use tools that are actually available on this system\n\
        3. Provide fallback commands if primary tool might not work\n\
        4. Explain what each command does\n\
        \n\
        Return your plan as JSON:\n\
        {\n\
          \"commands\": [\n\
            {\n\
              \"command\": \"pacman\",\n\
              \"args\": [\"-Q\", \"steam\"],\n\
              \"purpose\": \"Check if steam package is installed\",\n\
              \"requires_tools\": [\"pacman\"]\n\
            }\n\
          ],\n\
          \"safety_level\": \"ReadOnly\",\n\
          \"fallbacks\": [...],\n\
          \"expected_output\": \"Package names or error if not found\",\n\
          \"reasoning\": \"Use pacman to query installed packages, grep for game-related names\"\n\
        }\n"
    );

    prompt
}

/// v6.42.0: LLM-backed planner that uses real LLM for dynamic planning
pub struct LlmPlanner<'a> {
    llm_client: &'a dyn LlmClient,
    tool_inventory: ToolInventory,
}

impl<'a> LlmPlanner<'a> {
    pub fn new(llm_client: &'a dyn LlmClient, tool_inventory: ToolInventory) -> Self {
        Self {
            llm_client,
            tool_inventory,
        }
    }

    /// Plan commands using LLM, with fallback to deterministic planning
    pub fn plan(
        &self,
        intent: &Intent,
        system_signals: &serde_json::Value,
    ) -> Result<CommandPlan, LlmError> {
        // Try LLM-backed planning first
        match self.plan_with_llm(intent, system_signals) {
            Ok(plan) => {
                tracing::debug!("LLM planning succeeded");
                Ok(plan)
            }
            Err(e) => {
                tracing::debug!("LLM planning failed ({}), falling back to deterministic", e);
                // Fall back to deterministic planning
                Ok(fallback_plan(intent, &self.tool_inventory))
            }
        }
    }

    fn plan_with_llm(
        &self,
        intent: &Intent,
        system_signals: &serde_json::Value,
    ) -> Result<CommandPlan, LlmError> {
        let system_prompt = self.build_system_prompt();
        let user_prompt = self.build_user_prompt(intent, system_signals);
        let schema = self.get_plan_schema();

        let response_json = self.llm_client.call_json(&system_prompt, &user_prompt, &schema)?;

        // Parse response into CommandPlan
        self.parse_plan_json(response_json)
    }

    fn build_system_prompt(&self) -> String {
        "You are a system command planner for Arch Linux. \
        Your job is to generate safe, read-only shell commands that will gather information to answer the user's question. \
        You must ONLY use tools that are available on the system. \
        You must NEVER suggest destructive commands (rm, dd, mkfs, package removal). \
        Always provide your reasoning for the plan.".to_string()
    }

    fn build_user_prompt(&self, intent: &Intent, system_signals: &serde_json::Value) -> String {
        let mut prompt = format!(
            "User question: \"{}\"\n\n\
            Intent classification:\n\
            - Goal: {:?}\n\
            - Domain: {:?}\n",
            intent.query, intent.goal, intent.domain
        );

        if !intent.constraints.is_empty() {
            prompt.push_str("\nConstraints:\n");
            for constraint in &intent.constraints {
                prompt.push_str(&format!("  - {:?}\n", constraint));
            }
        }

        // Add tool inventory
        prompt.push_str("\nAvailable tools on this system:\n");
        let tools_json = self.tool_inventory.to_json_context();
        prompt.push_str(&serde_json::to_string_pretty(&tools_json).unwrap_or_default());

        // Add system signals
        prompt.push_str("\n\nSystem context:\n");
        prompt.push_str(&serde_json::to_string_pretty(system_signals).unwrap_or_default());

        prompt.push_str("\n\nGenerate a command plan to answer this question using only available tools.");

        prompt
    }

    fn get_plan_schema(&self) -> String {
        r#"{
  "commands": [
    {
      "command": "string (command name)",
      "args": ["array of string arguments"],
      "purpose": "string (what this command does)",
      "requires_tools": ["array of required tool names"]
    }
  ],
  "safety_level": "ReadOnly | MinimalWrite | Risky",
  "fallbacks": [
    {
      "command": "string",
      "args": ["array"],
      "purpose": "string",
      "requires_tools": ["array"]
    }
  ],
  "expected_output": "string describing what output to expect",
  "reasoning": "string explaining why this plan will answer the question"
}"#.to_string()
    }

    fn parse_plan_json(&self, json: serde_json::Value) -> Result<CommandPlan, LlmError> {
        let commands: Vec<PlannedCommand> = json
            .get("commands")
            .and_then(|v| v.as_array())
            .ok_or_else(|| LlmError::InvalidJson("Missing 'commands' array".to_string()))?
            .iter()
            .filter_map(|cmd_json| {
                let risk_level = match cmd_json.get("risk_level").and_then(|v| v.as_str()) {
                    Some("ReadOnly") => StepRiskLevel::ReadOnly,
                    Some("Low") => StepRiskLevel::Low,
                    Some("Medium") => StepRiskLevel::Medium,
                    Some("High") => StepRiskLevel::High,
                    _ => StepRiskLevel::ReadOnly, // Default to safe
                };

                Some(PlannedCommand {
                    command: cmd_json.get("command")?.as_str()?.to_string(),
                    args: cmd_json
                        .get("args")?
                        .as_array()?
                        .iter()
                        .filter_map(|v| v.as_str().map(|s| s.to_string()))
                        .collect(),
                    purpose: cmd_json.get("purpose")?.as_str()?.to_string(),
                    requires_tools: cmd_json
                        .get("requires_tools")?
                        .as_array()?
                        .iter()
                        .filter_map(|v| v.as_str().map(|s| s.to_string()))
                        .collect(),
                    risk_level,
                    writes_files: cmd_json.get("writes_files").and_then(|v| v.as_bool()).unwrap_or(false),
                    requires_root: cmd_json.get("requires_root").and_then(|v| v.as_bool()).unwrap_or(false),
                    expected_outcome: cmd_json.get("expected_outcome").and_then(|v| v.as_str()).map(|s| s.to_string()),
                    validation_hint: cmd_json.get("validation_hint").and_then(|v| v.as_str()).map(|s| s.to_string()),
                })
            })
            .collect();

        if commands.is_empty() {
            return Err(LlmError::InvalidJson("No valid commands in plan".to_string()));
        }

        let safety_level = match json.get("safety_level").and_then(|v| v.as_str()) {
            Some("ReadOnly") => SafetyLevel::ReadOnly,
            Some("MinimalWrite") => SafetyLevel::MinimalWrite,
            Some("Risky") => SafetyLevel::Risky,
            _ => SafetyLevel::ReadOnly, // Default to safe
        };

        let fallbacks: Vec<PlannedCommand> = json
            .get("fallbacks")
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|cmd_json| {
                        let risk_level = match cmd_json.get("risk_level").and_then(|v| v.as_str()) {
                            Some("ReadOnly") => StepRiskLevel::ReadOnly,
                            Some("Low") => StepRiskLevel::Low,
                            Some("Medium") => StepRiskLevel::Medium,
                            Some("High") => StepRiskLevel::High,
                            _ => StepRiskLevel::ReadOnly,
                        };

                        Some(PlannedCommand {
                            command: cmd_json.get("command")?.as_str()?.to_string(),
                            args: cmd_json
                                .get("args")?
                                .as_array()?
                                .iter()
                                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                                .collect(),
                            purpose: cmd_json.get("purpose")?.as_str()?.to_string(),
                            requires_tools: cmd_json
                                .get("requires_tools")?
                                .as_array()?
                                .iter()
                                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                                .collect(),
                            risk_level,
                            writes_files: cmd_json.get("writes_files").and_then(|v| v.as_bool()).unwrap_or(false),
                            requires_root: cmd_json.get("requires_root").and_then(|v| v.as_bool()).unwrap_or(false),
                            expected_outcome: cmd_json.get("expected_outcome").and_then(|v| v.as_str()).map(|s| s.to_string()),
                            validation_hint: cmd_json.get("validation_hint").and_then(|v| v.as_str()).map(|s| s.to_string()),
                        })
                    })
                    .collect()
            })
            .unwrap_or_default();

        let expected_output = json
            .get("expected_output")
            .and_then(|v| v.as_str())
            .unwrap_or("Command output")
            .to_string();

        let reasoning = json
            .get("reasoning")
            .and_then(|v| v.as_str())
            .unwrap_or("LLM-generated plan")
            .to_string();

        // v6.43.0: Parse approval flow metadata
        let goal_description = json
            .get("goal_description")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        let assumptions: Vec<String> = json
            .get("assumptions")
            .and_then(|v| v.as_array())
            .map(|arr| {
                arr.iter()
                    .filter_map(|v| v.as_str().map(|s| s.to_string()))
                    .collect()
            })
            .unwrap_or_default();

        let confidence = json
            .get("confidence")
            .and_then(|v| v.as_f64())
            .unwrap_or(0.8) as f32;

        Ok(CommandPlan {
            commands,
            safety_level,
            fallbacks,
            expected_output,
            reasoning,
            goal_description,
            assumptions,
            confidence,
        })
    }
}

/// Deterministic fallback planning (v6.41.0 logic)
pub fn fallback_plan(intent: &Intent, tool_inventory: &ToolInventory) -> CommandPlan {
    let mut commands = Vec::new();

    match intent.domain {
        DomainType::Packages => {
            if intent.query.to_lowercase().contains("game") {
                commands.push(PlannedCommand {
                    command: "sh".to_string(),
                    args: vec![
                        "-c".to_string(),
                        "pacman -Qq | grep -Ei '(steam|game|lutris|heroic|wine|proton)'".to_string(),
                    ],
                    purpose: "Find game-related packages".to_string(),
                    requires_tools: vec!["pacman".to_string(), "grep".to_string()],
                    risk_level: StepRiskLevel::ReadOnly,
                    writes_files: false,
                    requires_root: false,
                    expected_outcome: Some("List of game packages if any exist".to_string()),
                    validation_hint: Some("Non-empty output indicates games are installed".to_string()),
                });
            } else if intent.query.to_lowercase().contains("file manager") {
                commands.push(PlannedCommand {
                    command: "sh".to_string(),
                    args: vec![
                        "-c".to_string(),
                        "pacman -Qq | grep -Ei '(thunar|dolphin|nautilus|nemo|pcmanfm|ranger|mc)'".to_string(),
                    ],
                    purpose: "Find file manager packages".to_string(),
                    requires_tools: vec!["pacman".to_string(), "grep".to_string()],
                    risk_level: StepRiskLevel::ReadOnly,
                    writes_files: false,
                    requires_root: false,
                    expected_outcome: Some("List of file manager packages if any exist".to_string()),
                    validation_hint: Some("Non-empty output indicates file managers are installed".to_string()),
                });
            }
        }
        DomainType::Hardware => {
            let features: Vec<String> = intent
                .constraints
                .iter()
                .filter_map(|c| {
                    if let Constraint::Feature(f) = c {
                        Some(f.to_uppercase())
                    } else {
                        None
                    }
                })
                .collect();

            if !features.is_empty() {
                commands.push(PlannedCommand {
                    command: "sh".to_string(),
                    args: vec![
                        "-c".to_string(),
                        "lscpu | grep -i 'flags' || grep -i 'flags' /proc/cpuinfo | head -1".to_string(),
                    ],
                    purpose: format!("Get CPU flags to check for: {}", features.join(", ")),
                    requires_tools: vec!["lscpu".to_string(), "grep".to_string()],
                    risk_level: StepRiskLevel::ReadOnly,
                    writes_files: false,
                    requires_root: false,
                    expected_outcome: Some("CPU flags line from lscpu or /proc/cpuinfo".to_string()),
                    validation_hint: Some(format!("Check if output contains: {}", features.join(", "))),
                });
            }
        }
        DomainType::Gui => {
            commands.push(PlannedCommand {
                command: "echo".to_string(),
                args: vec!["DE_WM_DETECTOR".to_string()],
                purpose: "Use de_wm_detector module for accurate detection".to_string(),
                requires_tools: vec![],
                risk_level: StepRiskLevel::ReadOnly,
                writes_files: false,
                requires_root: false,
                expected_outcome: Some("Signal for de_wm_detector invocation".to_string()),
                validation_hint: None,
            });
        }
        _ => {
            // Generic fallback
            commands.push(PlannedCommand {
                command: "echo".to_string(),
                args: vec!["Unsupported query for fallback planner".to_string()],
                purpose: "Placeholder for unsupported domain".to_string(),
                requires_tools: vec![],
                risk_level: StepRiskLevel::ReadOnly,
                writes_files: false,
                requires_root: false,
                expected_outcome: None,
                validation_hint: None,
            });
        }
    }

    CommandPlan {
        commands,
        safety_level: SafetyLevel::ReadOnly,
        fallbacks: vec![],
        expected_output: "Command outputs for analysis".to_string(),
        reasoning: "Deterministic fallback plan (LLM unavailable)".to_string(),
        goal_description: Some(intent.query.clone()),
        assumptions: vec!["Using deterministic fallback (LLM unavailable)".to_string()],
        confidence: 0.7, // Fallback plans are reasonably confident but not as good as LLM
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_interpret_games_query() {
        let intent = interpret_intent("do I have games installed?");
        assert_eq!(intent.goal, GoalType::Inspect);
        assert_eq!(intent.domain, DomainType::Packages);
        assert!(intent.constraints.iter().any(|c| matches!(c, Constraint::Category(cat) if cat == "games")));
    }

    #[test]
    fn test_interpret_de_wm_query() {
        let intent = interpret_intent("what DE and WM am I running?");
        assert_eq!(intent.goal, GoalType::List);
        assert_eq!(intent.domain, DomainType::Gui);
    }

    #[test]
    fn test_interpret_cpu_features() {
        let intent = interpret_intent("does my CPU have SSE and AVX?");
        assert_eq!(intent.goal, GoalType::Check);
        assert_eq!(intent.domain, DomainType::Hardware);
        let features: Vec<_> = intent.constraints.iter()
            .filter_map(|c| if let Constraint::Feature(f) = c { Some(f.as_str()) } else { None })
            .collect();
        assert!(features.contains(&"sse"));
        assert!(features.contains(&"avx"));
    }

    #[test]
    fn test_extract_count() {
        let intent = interpret_intent("show me the top 10 folders");
        assert!(intent.constraints.iter().any(|c| matches!(c, Constraint::Count(10))));
    }

    // v6.42.0: LLM Planner tests
    use crate::llm_client::{FakeLlmClient, LlmError};

    #[test]
    fn test_llm_planner_valid_json() {
        let valid_plan = serde_json::json!({
            "commands": [{
                "command": "pacman",
                "args": ["-Qq", "steam"],
                "purpose": "Check if steam is installed",
                "requires_tools": ["pacman"]
            }],
            "safety_level": "ReadOnly",
            "fallbacks": [],
            "expected_output": "Package name or error",
            "reasoning": "Query pacman for steam package"
        });

        let fake_client = FakeLlmClient::always_valid(valid_plan);
        let tool_inventory = ToolInventory::default();
        let planner = LlmPlanner::new(&fake_client, tool_inventory);

        let intent = interpret_intent("do I have steam?");
        let system_signals = serde_json::json!({});

        let result = planner.plan(&intent, &system_signals);
        assert!(result.is_ok());

        let plan = result.unwrap();
        assert_eq!(plan.commands.len(), 1);
        assert_eq!(plan.commands[0].command, "pacman");
        assert_eq!(plan.safety_level, SafetyLevel::ReadOnly);
    }

    #[test]
    fn test_llm_planner_invalid_json_fallback() {
        let fake_client = FakeLlmClient::always_error(LlmError::InvalidJson(
            "Malformed JSON".to_string(),
        ));
        let tool_inventory = ToolInventory::default();
        let planner = LlmPlanner::new(&fake_client, tool_inventory);

        let intent = interpret_intent("do I have games?");
        let system_signals = serde_json::json!({});

        let result = planner.plan(&intent, &system_signals);
        assert!(result.is_ok()); // Should succeed via fallback

        let plan = result.unwrap();
        assert!(plan.reasoning.contains("fallback"));
    }

    #[test]
    fn test_llm_planner_timeout_fallback() {
        let fake_client = FakeLlmClient::always_error(LlmError::Timeout(30));
        let tool_inventory = ToolInventory::default();
        let planner = LlmPlanner::new(&fake_client, tool_inventory);

        let intent = interpret_intent("what DE am I running?");
        let system_signals = serde_json::json!({});

        let result = planner.plan(&intent, &system_signals);
        assert!(result.is_ok()); // Should succeed via fallback

        let plan = result.unwrap();
        assert_eq!(plan.safety_level, SafetyLevel::ReadOnly);
    }

    #[test]
    fn test_llm_planner_disabled_fallback() {
        let fake_client = FakeLlmClient::always_error(LlmError::Disabled);
        let tool_inventory = ToolInventory::default();
        let planner = LlmPlanner::new(&fake_client, tool_inventory);

        let intent = interpret_intent("does my CPU have SSE?");
        let system_signals = serde_json::json!({});

        let result = planner.plan(&intent, &system_signals);
        assert!(result.is_ok());
    }

    #[test]
    fn test_fallback_plan_games() {
        let tool_inventory = ToolInventory::default();
        let intent = interpret_intent("do I have games?");

        let plan = fallback_plan(&intent, &tool_inventory);
        assert!(!plan.commands.is_empty());
        assert_eq!(plan.safety_level, SafetyLevel::ReadOnly);
        assert!(plan.reasoning.contains("fallback"));
    }

    #[test]
    fn test_fallback_plan_de_wm() {
        let tool_inventory = ToolInventory::default();
        let intent = interpret_intent("what DE am I running?");

        let plan = fallback_plan(&intent, &tool_inventory);
        assert!(!plan.commands.is_empty());
        assert_eq!(plan.commands[0].command, "echo");
        assert!(plan.commands[0].args[0].contains("DE_WM_DETECTOR"));
    }

    // v6.50.0: Test plan summary computation
    #[test]
    fn test_compute_plan_summary_safe() {
        use crate::execution_safety::{ExecutionMode, RiskLevel};

        let plan = CommandPlan {
            commands: vec![PlannedCommand {
                command: "ls".to_string(),
                args: vec!["-la".to_string()],
                purpose: "list files".to_string(),
                requires_tools: vec![],
                risk_level: StepRiskLevel::ReadOnly,
                writes_files: false,
                requires_root: false,
                expected_outcome: None,
                validation_hint: None,
            }],
            safety_level: SafetyLevel::ReadOnly,
            fallbacks: vec![],
            expected_output: "files".to_string(),
            reasoning: "test".to_string(),
            goal_description: Some("List files".to_string()),
            assumptions: vec![],
            confidence: 0.9,
        };

        let summary = plan.compute_plan_summary(true);
        assert_eq!(summary.risk_level, RiskLevel::Safe);
        assert_eq!(summary.execution_mode, ExecutionMode::ConfirmRequired);
        assert_eq!(summary.command_count, 1);
    }

    #[test]
    fn test_compute_plan_summary_moderate() {
        use crate::execution_safety::{ExecutionMode, RiskLevel};

        let plan = CommandPlan {
            commands: vec![PlannedCommand {
                command: "systemctl".to_string(),
                args: vec!["restart".to_string(), "sshd".to_string()],
                purpose: "restart service".to_string(),
                requires_tools: vec![],
                risk_level: StepRiskLevel::Medium,
                writes_files: false,
                requires_root: true,
                expected_outcome: None,
                validation_hint: None,
            }],
            safety_level: SafetyLevel::Risky,
            fallbacks: vec![],
            expected_output: "service restarted".to_string(),
            reasoning: "test".to_string(),
            goal_description: Some("Restart SSH".to_string()),
            assumptions: vec![],
            confidence: 0.85,
        };

        let summary = plan.compute_plan_summary(true);
        assert_eq!(summary.risk_level, RiskLevel::Moderate);
        assert_eq!(summary.execution_mode, ExecutionMode::ConfirmRequired);
    }

    #[test]
    fn test_compute_plan_summary_high_risk() {
        use crate::execution_safety::{ExecutionMode, RiskLevel};

        let plan = CommandPlan {
            commands: vec![PlannedCommand {
                command: "fdisk".to_string(),
                args: vec!["/dev/sda".to_string()],
                purpose: "partition disk".to_string(),
                requires_tools: vec![],
                risk_level: StepRiskLevel::High,
                writes_files: true,
                requires_root: true,
                expected_outcome: None,
                validation_hint: None,
            }],
            safety_level: SafetyLevel::Risky,
            fallbacks: vec![],
            expected_output: "disk partitioned".to_string(),
            reasoning: "test".to_string(),
            goal_description: Some("Partition disk".to_string()),
            assumptions: vec![],
            confidence: 0.7,
        };

        let summary = plan.compute_plan_summary(true);
        assert_eq!(summary.risk_level, RiskLevel::High);
        assert_eq!(summary.execution_mode, ExecutionMode::PlanOnly);
    }

    #[test]
    fn test_compute_plan_summary_one_shot_mode() {
        use crate::execution_safety::{ExecutionMode, RiskLevel};

        let plan = CommandPlan {
            commands: vec![PlannedCommand {
                command: "ls".to_string(),
                args: vec![],
                purpose: "list".to_string(),
                requires_tools: vec![],
                risk_level: StepRiskLevel::ReadOnly,
                writes_files: false,
                requires_root: false,
                expected_outcome: None,
                validation_hint: None,
            }],
            safety_level: SafetyLevel::ReadOnly,
            fallbacks: vec![],
            expected_output: "files".to_string(),
            reasoning: "test".to_string(),
            goal_description: None,
            assumptions: vec![],
            confidence: 0.9,
        };

        let summary = plan.compute_plan_summary(false); // non-interactive
        assert_eq!(summary.risk_level, RiskLevel::Safe);
        assert_eq!(summary.execution_mode, ExecutionMode::PlanOnly);
    }
}
