//! Planner Core - LLM-driven command planning
//!
//! v6.41.0: The Planner receives user intent + telemetry and uses the LLM
//! to generate system-specific commands that will answer the question.
//!
//! This replaces hardcoded handlers with dynamic planning.

use serde::{Deserialize, Serialize};

/// User intent classification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Intent {
    /// Goal type (Inspect, Diagnose, List, Check)
    pub goal: GoalType,

    /// Domain (packages, hardware, audio, GUI, filesystem, etc.)
    pub domain: DomainType,

    /// Constraints (path, count, specific features)
    pub constraints: Vec<Constraint>,

    /// Original query text
    pub query: String,
}

/// Goal types for user queries
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum GoalType {
    /// Inspect system state ("do I have X?")
    Inspect,

    /// Diagnose issues ("is Y configured correctly?")
    Diagnose,

    /// List items ("show me Z")
    List,

    /// Check capabilities ("does my system support X?")
    Check,
}

/// Domain types for queries
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum DomainType {
    /// Package management (installed packages, games, apps)
    Packages,

    /// Hardware (CPU, GPU, RAM, disk)
    Hardware,

    /// Audio system (PipeWire, PulseAudio, ALSA)
    Audio,

    /// GUI (DE, WM, display servers)
    Gui,

    /// Filesystem (disk space, directories)
    Filesystem,

    /// Services (systemd, daemons)
    Services,

    /// Network (connectivity, interfaces)
    Network,
}

/// Query constraints
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Constraint {
    /// Path constraint (e.g., "/home")
    Path(String),

    /// Count limit (e.g., "top 10")
    Count(usize),

    /// Feature name (e.g., "SSE", "AVX")
    Feature(String),

    /// Category (e.g., "games", "file managers")
    Category(String),
}

/// Command plan generated by LLM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommandPlan {
    /// Ordered list of shell commands to run
    pub commands: Vec<PlannedCommand>,

    /// Safety classification
    pub safety_level: SafetyLevel,

    /// Fallback options if tools are missing
    pub fallbacks: Vec<PlannedCommand>,

    /// Expected output shape
    pub expected_output: String,

    /// LLM reasoning for this plan
    pub reasoning: String,
}

/// A single planned command
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlannedCommand {
    /// Command to execute
    pub command: String,

    /// Arguments
    pub args: Vec<String>,

    /// Expected purpose ("check for steam package")
    pub purpose: String,

    /// Required tools that must exist
    pub requires_tools: Vec<String>,
}

/// Safety level for commands
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum SafetyLevel {
    /// Read-only, completely safe (grep, ls, pacman -Q)
    ReadOnly,

    /// May write logs or cache, but no system changes
    MinimalWrite,

    /// Risky operations (package install, file deletion)
    Risky,
}

/// Interpret user query into structured intent
pub fn interpret_intent(query: &str) -> Intent {
    let query_lower = query.to_lowercase();

    // Determine goal type
    let goal = if query_lower.contains("do i have") || query_lower.contains("is") {
        GoalType::Inspect
    } else if query_lower.contains("show") || query_lower.contains("list") || query_lower.contains("what") {
        GoalType::List
    } else if query_lower.contains("does") || query_lower.contains("can") {
        GoalType::Check
    } else if query_lower.contains("why") || query_lower.contains("problem") {
        GoalType::Diagnose
    } else {
        GoalType::Inspect // Default
    };

    // Determine domain
    let domain = if query_lower.contains("game") || query_lower.contains("package")
        || query_lower.contains("app") || query_lower.contains("file manager")
        || query_lower.contains("browser") {
        DomainType::Packages
    } else if query_lower.contains("cpu") || query_lower.contains("gpu")
        || query_lower.contains("ram") || query_lower.contains("memory")
        || query_lower.contains("vram") {
        DomainType::Hardware
    } else if query_lower.contains("sound") || query_lower.contains("audio") {
        DomainType::Audio
    } else if query_lower.contains("de") || query_lower.contains("wm")
        || query_lower.contains("desktop") || query_lower.contains("window manager") {
        DomainType::Gui
    } else if query_lower.contains("disk") || query_lower.contains("folder")
        || query_lower.contains("space") || query_lower.contains("directory") {
        DomainType::Filesystem
    } else if query_lower.contains("service") || query_lower.contains("systemd") {
        DomainType::Services
    } else if query_lower.contains("network") || query_lower.contains("wifi") {
        DomainType::Network
    } else {
        DomainType::Packages // Default
    };

    // Extract constraints
    let mut constraints = Vec::new();

    // Path constraint
    if let Some(pos) = query_lower.find("in /") {
        let path_start = pos + 3;
        let path_end = query[path_start..].find(' ').map(|p| path_start + p).unwrap_or(query.len());
        constraints.push(Constraint::Path(query[path_start..path_end].to_string()));
    } else if query_lower.contains("home") || query_lower.contains("$home") {
        constraints.push(Constraint::Path("$HOME".to_string()));
    }

    // Count constraint (top N, biggest N)
    if let Some(num) = extract_number_from_query(&query_lower) {
        constraints.push(Constraint::Count(num));
    }

    // Feature constraint (SSE, AVX, etc.)
    for feature in &["sse", "sse2", "sse3", "sse4", "avx", "avx2", "avx-512"] {
        if query_lower.contains(feature) {
            constraints.push(Constraint::Feature(feature.to_string()));
        }
    }

    // Category constraint
    if query_lower.contains("game") {
        constraints.push(Constraint::Category("games".to_string()));
    } else if query_lower.contains("file manager") {
        constraints.push(Constraint::Category("file_managers".to_string()));
    } else if query_lower.contains("browser") {
        constraints.push(Constraint::Category("browsers".to_string()));
    }

    Intent {
        goal,
        domain,
        constraints,
        query: query.to_string(),
    }
}

/// Extract number from query (e.g., "top 10" -> 10)
fn extract_number_from_query(query: &str) -> Option<usize> {
    let words: Vec<&str> = query.split_whitespace().collect();
    for (i, word) in words.iter().enumerate() {
        if (*word == "top" || *word == "biggest" || *word == "largest") && i + 1 < words.len() {
            if let Ok(num) = words[i + 1].parse::<usize>() {
                return Some(num);
            }
        }
    }
    None
}

/// Build LLM prompt for command planning
pub fn build_planner_prompt(intent: &Intent, telemetry_summary: &str, available_tools: &[String]) -> String {
    let mut prompt = format!(
        "# Command Planning Task\n\n\
        User query: \"{}\"\n\n\
        ## Interpreted Intent\n\
        Goal: {:?}\n\
        Domain: {:?}\n",
        intent.query, intent.goal, intent.domain
    );

    if !intent.constraints.is_empty() {
        prompt.push_str("\nConstraints:\n");
        for constraint in &intent.constraints {
            prompt.push_str(&format!("  - {:?}\n", constraint));
        }
    }

    prompt.push_str(&format!(
        "\n## System Context\n{}\n\n\
        ## Available Tools\n\
        Your system has these package managers and tools:\n",
        telemetry_summary
    ));

    for tool in available_tools {
        prompt.push_str(&format!("  - {}\n", tool));
    }

    prompt.push_str(
        "\n## Your Task\n\
        Generate a list of shell commands that will answer the user's question on THIS SPECIFIC SYSTEM.\n\
        \n\
        Requirements:\n\
        1. Commands must be read-only (no package installs, no file deletions)\n\
        2. Use tools that are actually available on this system\n\
        3. Provide fallback commands if primary tool might not work\n\
        4. Explain what each command does\n\
        \n\
        Return your plan as JSON:\n\
        {\n\
          \"commands\": [\n\
            {\n\
              \"command\": \"pacman\",\n\
              \"args\": [\"-Q\", \"steam\"],\n\
              \"purpose\": \"Check if steam package is installed\",\n\
              \"requires_tools\": [\"pacman\"]\n\
            }\n\
          ],\n\
          \"safety_level\": \"ReadOnly\",\n\
          \"fallbacks\": [...],\n\
          \"expected_output\": \"Package names or error if not found\",\n\
          \"reasoning\": \"Use pacman to query installed packages, grep for game-related names\"\n\
        }\n"
    );

    prompt
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_interpret_games_query() {
        let intent = interpret_intent("do I have games installed?");
        assert_eq!(intent.goal, GoalType::Inspect);
        assert_eq!(intent.domain, DomainType::Packages);
        assert!(intent.constraints.iter().any(|c| matches!(c, Constraint::Category(cat) if cat == "games")));
    }

    #[test]
    fn test_interpret_de_wm_query() {
        let intent = interpret_intent("what DE and WM am I running?");
        assert_eq!(intent.goal, GoalType::List);
        assert_eq!(intent.domain, DomainType::Gui);
    }

    #[test]
    fn test_interpret_cpu_features() {
        let intent = interpret_intent("does my CPU have SSE and AVX?");
        assert_eq!(intent.goal, GoalType::Check);
        assert_eq!(intent.domain, DomainType::Hardware);
        let features: Vec<_> = intent.constraints.iter()
            .filter_map(|c| if let Constraint::Feature(f) = c { Some(f.as_str()) } else { None })
            .collect();
        assert!(features.contains(&"sse"));
        assert!(features.contains(&"avx"));
    }

    #[test]
    fn test_extract_count() {
        let intent = interpret_intent("show me the top 10 folders");
        assert!(intent.constraints.iter().any(|c| matches!(c, Constraint::Count(10))));
    }
}
