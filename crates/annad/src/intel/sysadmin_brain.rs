//! Sysadmin Brain - Deterministic Systems Intelligence
//!
//! Beta.217a: Sysadmin Brain Foundation
//!
//! Pure logic-based diagnostic engine that interprets telemetry data
//! and generates actionable insights. No LLM inference - just deterministic rules
//! based on real system administration knowledge.
//!
//! Philosophy:
//! - Every insight backed by concrete telemetry evidence
//! - Every recommendation includes specific commands to run
//! - Every rule cites documentation (man pages, Arch Wiki)
//! - Zero hallucinations - if we don't know, we don't guess

use crate::steward::{HealthReport, HealthStatus, LogIssue, ServiceStatus};
use serde::{Deserialize, Serialize};

/// Severity level for diagnostic insights
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum DiagnosticSeverity {
    /// Informational - no action needed
    Info,
    /// Warning - should investigate
    Warning,
    /// Critical - requires immediate attention
    Critical,
}

/// A diagnostic insight generated by the sysadmin brain
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiagnosticInsight {
    /// Unique identifier for this type of insight
    pub rule_id: String,

    /// Severity level
    pub severity: DiagnosticSeverity,

    /// Summary - one sentence describing the issue
    pub summary: String,

    /// Detailed explanation of what was detected
    pub details: String,

    /// Commands to diagnose or fix the issue
    pub commands: Vec<String>,

    /// Documentation citations (man pages, Arch Wiki URLs)
    pub citations: Vec<String>,

    /// Evidence from telemetry that triggered this rule
    pub evidence: String,
}

/// Analyze system health and generate diagnostic insights
///
/// This is the main entry point for the sysadmin brain. It takes a HealthReport
/// and runs all diagnostic rules, returning a list of insights.
pub fn analyze_system_health(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Run all diagnostic rules
    insights.extend(check_failed_services(health));
    insights.extend(check_degraded_services(health));
    insights.extend(check_log_issues(health));
    insights.extend(check_overall_health(health));

    // Beta.217b: Additional diagnostic rules
    insights.extend(check_disk_space());
    insights.extend(check_memory_pressure());
    insights.extend(check_cpu_usage());
    insights.extend(check_orphan_packages());
    insights.extend(check_failed_mounts());

    insights
}

/// Rule: Detect failed systemd services
fn check_failed_services(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    let failed_services: Vec<&ServiceStatus> = health
        .services
        .iter()
        .filter(|s| s.state == "failed")
        .collect();

    if !failed_services.is_empty() {
        let service_names: Vec<&str> = failed_services
            .iter()
            .map(|s| s.name.as_str())
            .collect();

        let commands = vec![
            format!("systemctl status {}", service_names.join(" ")),
            format!("journalctl -u {} -n 50 --no-pager", service_names[0]),
        ];

        insights.push(DiagnosticInsight {
            rule_id: "failed_services".to_string(),
            severity: DiagnosticSeverity::Critical,
            summary: format!("{} systemd service(s) in failed state", failed_services.len()),
            details: format!(
                "The following services have failed: {}. Failed services indicate \
                 that system components are not running as expected and may impact \
                 system functionality.",
                service_names.join(", ")
            ),
            commands,
            citations: vec![
                "man systemctl".to_string(),
                "man journalctl".to_string(),
                "https://wiki.archlinux.org/title/Systemd#Using_units".to_string(),
            ],
            evidence: format!("Failed services detected: {}", service_names.join(", ")),
        });
    }

    insights
}

/// Rule: Detect degraded or inactive-dead services that should be running
fn check_degraded_services(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Services that are loaded but inactive-dead (not running but should be)
    let degraded_services: Vec<&ServiceStatus> = health
        .services
        .iter()
        .filter(|s| {
            s.state == "inactive" &&
            s.load == "loaded" &&
            s.sub == "dead" &&
            // Only flag important system services, not user services
            (s.name.contains("network") ||
             s.name.contains("bluetooth") ||
             s.name.contains("cups") ||
             s.name == "annad.service")
        })
        .collect();

    if !degraded_services.is_empty() {
        let service_names: Vec<&str> = degraded_services
            .iter()
            .map(|s| s.name.as_str())
            .collect();

        insights.push(DiagnosticInsight {
            rule_id: "degraded_services".to_string(),
            severity: DiagnosticSeverity::Warning,
            summary: format!("{} important service(s) loaded but not running", degraded_services.len()),
            details: format!(
                "The following important services are loaded but not currently running: {}. \
                 These services may need to be started for full system functionality.",
                service_names.join(", ")
            ),
            commands: vec![
                format!("systemctl is-enabled {}", service_names.join(" ")),
                format!("sudo systemctl start {}", service_names[0]),
            ],
            citations: vec![
                "man systemctl".to_string(),
                "https://wiki.archlinux.org/title/Systemd#Using_units".to_string(),
            ],
            evidence: format!("Inactive services: {}", service_names.join(", ")),
        });
    }

    insights
}

/// Rule: Detect critical log issues
fn check_log_issues(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Group log issues by severity
    let critical_issues: Vec<&LogIssue> = health
        .log_issues
        .iter()
        .filter(|issue| issue.severity == "critical" || issue.severity == "error")
        .collect();

    if !critical_issues.is_empty() {
        // Take the most frequent critical issue
        let top_issue = critical_issues
            .iter()
            .max_by_key(|issue| issue.count)
            .unwrap();

        insights.push(DiagnosticInsight {
            rule_id: "critical_log_issues".to_string(),
            severity: DiagnosticSeverity::Critical,
            summary: format!("{} critical log issue(s) detected", critical_issues.len()),
            details: format!(
                "System logs contain {} critical or error-level issues. \
                 Most frequent: \"{}\" from {} (seen {} times since {}).",
                critical_issues.len(),
                top_issue.message,
                top_issue.source,
                top_issue.count,
                top_issue.first_seen.format("%Y-%m-%d %H:%M")
            ),
            commands: vec![
                format!("journalctl -p err -n 20 --no-pager"),
                format!("journalctl -p crit -n 20 --no-pager"),
                format!("journalctl --since \"1 hour ago\" | grep -i error | head -20"),
            ],
            citations: vec![
                "man journalctl".to_string(),
                "https://wiki.archlinux.org/title/Systemd/Journal".to_string(),
            ],
            evidence: format!(
                "Critical issues: {} (most frequent: {} occurrences)",
                critical_issues.len(),
                top_issue.count
            ),
        });
    }

    insights
}

/// Rule: Overall health status assessment
fn check_overall_health(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    match health.overall_status {
        HealthStatus::Critical => {
            insights.push(DiagnosticInsight {
                rule_id: "overall_health_critical".to_string(),
                severity: DiagnosticSeverity::Critical,
                summary: "System health is critical".to_string(),
                details: format!(
                    "Overall system health assessment is CRITICAL. {}",
                    health.message
                ),
                commands: vec![
                    "systemctl --failed".to_string(),
                    "journalctl -p err -n 50 --no-pager".to_string(),
                    "df -h".to_string(),
                    "free -h".to_string(),
                ],
                citations: vec![
                    health.citation.clone(),
                ],
                evidence: format!("HealthStatus::Critical - {}", health.message),
            });
        }
        HealthStatus::Degraded => {
            insights.push(DiagnosticInsight {
                rule_id: "overall_health_degraded".to_string(),
                severity: DiagnosticSeverity::Warning,
                summary: "System health is degraded".to_string(),
                details: format!(
                    "Overall system health assessment is DEGRADED. {}",
                    health.message
                ),
                commands: vec![
                    "systemctl --failed".to_string(),
                    "journalctl -p warning -n 50 --no-pager".to_string(),
                ],
                citations: vec![
                    health.citation.clone(),
                ],
                evidence: format!("HealthStatus::Degraded - {}", health.message),
            });
        }
        HealthStatus::Healthy => {
            // Don't generate insight for healthy systems unless explicitly requested
        }
    }

    insights
}

/// Rule: Check disk space usage (Beta.217b)
fn check_disk_space() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Run df to check disk usage
    let output = std::process::Command::new("df")
        .args(["-h", "--output=source,size,used,avail,pcent,target"])
        .output();

    if let Ok(output) = output {
        if output.status.success() {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let mut critical_filesystems = Vec::new();
            let mut warning_filesystems = Vec::new();

            for line in stdout.lines().skip(1) {
                // Skip header
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 6 {
                    let device = parts[0];
                    let size = parts[1];
                    let used = parts[2];
                    let avail = parts[3];
                    let usage_str = parts[4];
                    let mount = parts[5];

                    // Parse usage percentage
                    if let Some(percent_str) = usage_str.strip_suffix('%') {
                        if let Ok(usage_percent) = percent_str.parse::<u32>() {
                            if usage_percent >= 90 {
                                critical_filesystems.push((mount, device, usage_percent, avail));
                            } else if usage_percent >= 80 {
                                warning_filesystems.push((mount, device, usage_percent, avail));
                            }
                        }
                    }
                }
            }

            // Critical disk space
            if !critical_filesystems.is_empty() {
                let fs_details: Vec<String> = critical_filesystems
                    .iter()
                    .map(|(mount, dev, pct, avail)| {
                        format!("{} ({}): {}% full, {} available", mount, dev, pct, avail)
                    })
                    .collect();

                insights.push(DiagnosticInsight {
                    rule_id: "disk_space_critical".to_string(),
                    severity: DiagnosticSeverity::Critical,
                    summary: format!("{} filesystem(s) critically low on space", critical_filesystems.len()),
                    details: format!(
                        "Critical disk space situation detected:\n\n{}\n\n\
                         Filesystems above 90% capacity can cause system instability, \
                         failed updates, and application crashes. Immediate cleanup required.",
                        fs_details.join("\n")
                    ),
                    commands: vec![
                        "df -h".to_string(),
                        "du -sh /* 2>/dev/null | sort -h | tail -20".to_string(),
                        "journalctl --disk-usage".to_string(),
                        "pacman -Sc".to_string(),
                    ],
                    citations: vec![
                        "man df".to_string(),
                        "man du".to_string(),
                        "https://wiki.archlinux.org/title/Pacman#Cleaning_the_package_cache".to_string(),
                    ],
                    evidence: format!("Critical filesystems: {}",
                        critical_filesystems.iter()
                            .map(|(m, _, p, _)| format!("{} ({}%)", m, p))
                            .collect::<Vec<_>>()
                            .join(", ")
                    ),
                });
            }

            // Warning disk space
            if !warning_filesystems.is_empty() && critical_filesystems.is_empty() {
                let fs_details: Vec<String> = warning_filesystems
                    .iter()
                    .map(|(mount, dev, pct, avail)| {
                        format!("{} ({}): {}% full, {} available", mount, dev, pct, avail)
                    })
                    .collect();

                insights.push(DiagnosticInsight {
                    rule_id: "disk_space_warning".to_string(),
                    severity: DiagnosticSeverity::Warning,
                    summary: format!("{} filesystem(s) low on space", warning_filesystems.len()),
                    details: format!(
                        "Disk space warning:\n\n{}\n\n\
                         Consider cleaning up old files, package cache, or logs before \
                         space becomes critical.",
                        fs_details.join("\n")
                    ),
                    commands: vec![
                        "df -h".to_string(),
                        "du -sh /var/cache/pacman/pkg".to_string(),
                        "journalctl --vacuum-time=30d".to_string(),
                    ],
                    citations: vec![
                        "man df".to_string(),
                        "https://wiki.archlinux.org/title/System_maintenance".to_string(),
                    ],
                    evidence: format!("Warning filesystems: {}",
                        warning_filesystems.iter()
                            .map(|(m, _, p, _)| format!("{} ({}%)", m, p))
                            .collect::<Vec<_>>()
                            .join(", ")
                    ),
                });
            }
        }
    }

    insights
}

/// Rule: Check memory pressure (Beta.217b)
fn check_memory_pressure() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Use sysinfo to check memory usage
    let mut sys = sysinfo::System::new_all();
    sys.refresh_memory();

    let total_mem = sys.total_memory();
    let used_mem = sys.used_memory();
    let available_mem = sys.available_memory();
    let swap_total = sys.total_swap();
    let swap_used = sys.used_swap();

    if total_mem > 0 {
        let mem_usage_percent = (used_mem as f64 / total_mem as f64 * 100.0) as u32;
        let swap_usage_percent = if swap_total > 0 {
            (swap_used as f64 / swap_total as f64 * 100.0) as u32
        } else {
            0
        };

        // Critical memory pressure: >95% used or heavy swap
        if mem_usage_percent >= 95 || swap_usage_percent >= 80 {
            insights.push(DiagnosticInsight {
                rule_id: "memory_pressure_critical".to_string(),
                severity: DiagnosticSeverity::Critical,
                summary: "Critical memory pressure detected".to_string(),
                details: format!(
                    "System is under severe memory pressure:\n\n\
                     - Physical RAM: {}% used ({} MB / {} MB)\n\
                     - Available: {} MB\n\
                     - Swap: {}% used ({} MB / {} MB)\n\n\
                     High memory usage can cause system slowdowns, OOM killer activation, \
                     and application crashes. Identify and stop memory-intensive processes.",
                    mem_usage_percent,
                    used_mem / 1024 / 1024,
                    total_mem / 1024 / 1024,
                    available_mem / 1024 / 1024,
                    swap_usage_percent,
                    swap_used / 1024 / 1024,
                    swap_total / 1024 / 1024
                ),
                commands: vec![
                    "free -h".to_string(),
                    "ps aux --sort=-%mem | head -20".to_string(),
                    "systemd-cgtop -n 1 -m".to_string(),
                    "journalctl -k | grep -i 'out of memory'".to_string(),
                ],
                citations: vec![
                    "man free".to_string(),
                    "man ps".to_string(),
                    "https://wiki.archlinux.org/title/Improving_performance#Memory".to_string(),
                ],
                evidence: format!(
                    "Memory {}% used, Swap {}% used",
                    mem_usage_percent, swap_usage_percent
                ),
            });
        }
        // Warning: >85% memory usage
        else if mem_usage_percent >= 85 {
            insights.push(DiagnosticInsight {
                rule_id: "memory_pressure_warning".to_string(),
                severity: DiagnosticSeverity::Warning,
                summary: "High memory usage detected".to_string(),
                details: format!(
                    "Memory usage is elevated:\n\n\
                     - Physical RAM: {}% used ({} MB / {} MB)\n\
                     - Available: {} MB\n\n\
                     Consider closing unused applications or investigating memory leaks.",
                    mem_usage_percent,
                    used_mem / 1024 / 1024,
                    total_mem / 1024 / 1024,
                    available_mem / 1024 / 1024
                ),
                commands: vec![
                    "free -h".to_string(),
                    "ps aux --sort=-%mem | head -10".to_string(),
                ],
                citations: vec![
                    "man free".to_string(),
                    "https://wiki.archlinux.org/title/System_maintenance".to_string(),
                ],
                evidence: format!("Memory {}% used", mem_usage_percent),
            });
        }
    }

    insights
}

/// Rule: Check CPU usage patterns (Beta.217b)
fn check_cpu_usage() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Read load average
    if let Ok(loadavg_str) = std::fs::read_to_string("/proc/loadavg") {
        let parts: Vec<&str> = loadavg_str.split_whitespace().collect();
        if parts.len() >= 3 {
            if let (Ok(load1), Ok(load5), Ok(load15)) = (
                parts[0].parse::<f64>(),
                parts[1].parse::<f64>(),
                parts[2].parse::<f64>(),
            ) {
                // Get CPU count
                let cpu_count = num_cpus::get() as f64;

                // Load average above CPU count indicates saturation
                let normalized_load1 = load1 / cpu_count;
                let normalized_load5 = load5 / cpu_count;
                let normalized_load15 = load15 / cpu_count;

                // Critical: sustained high load across all intervals
                if normalized_load1 > 2.0 && normalized_load5 > 1.5 && normalized_load15 > 1.0 {
                    insights.push(DiagnosticInsight {
                        rule_id: "cpu_overload_critical".to_string(),
                        severity: DiagnosticSeverity::Critical,
                        summary: "Critical CPU overload detected".to_string(),
                        details: format!(
                            "System is experiencing sustained CPU overload:\n\n\
                             - Load averages: {:.2}, {:.2}, {:.2} (1m, 5m, 15m)\n\
                             - CPU cores: {}\n\
                             - Normalized load: {:.2}, {:.2}, {:.2}\n\n\
                             Sustained high load can cause system unresponsiveness and \
                             application timeouts. Identify CPU-intensive processes.",
                            load1, load5, load15, cpu_count as u32,
                            normalized_load1, normalized_load5, normalized_load15
                        ),
                        commands: vec![
                            "uptime".to_string(),
                            "ps aux --sort=-%cpu | head -20".to_string(),
                            "systemd-cgtop -n 1 -c".to_string(),
                            "top -b -n 1 | head -20".to_string(),
                        ],
                        citations: vec![
                            "man uptime".to_string(),
                            "man top".to_string(),
                            "https://wiki.archlinux.org/title/Improving_performance#CPU".to_string(),
                        ],
                        evidence: format!(
                            "Load averages {:.2}/{:.2}/{:.2} on {} cores",
                            load1, load5, load15, cpu_count as u32
                        ),
                    });
                }
                // Warning: elevated load
                else if normalized_load5 > 1.2 {
                    insights.push(DiagnosticInsight {
                        rule_id: "cpu_high_load".to_string(),
                        severity: DiagnosticSeverity::Warning,
                        summary: "Elevated CPU load detected".to_string(),
                        details: format!(
                            "CPU load is elevated:\n\n\
                             - Load averages: {:.2}, {:.2}, {:.2} (1m, 5m, 15m)\n\
                             - CPU cores: {}\n\n\
                             System may be running intensive workloads.",
                            load1, load5, load15, cpu_count as u32
                        ),
                        commands: vec![
                            "uptime".to_string(),
                            "ps aux --sort=-%cpu | head -10".to_string(),
                        ],
                        citations: vec!["man uptime".to_string()],
                        evidence: format!("5-min load {:.2} on {} cores", load5, cpu_count as u32),
                    });
                }
            }
        }
    }

    insights
}

/// Rule: Check for orphaned packages (Beta.217b)
fn check_orphan_packages() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Check for orphaned packages
    let output = std::process::Command::new("pacman")
        .args(["-Qdtq"])
        .output();

    if let Ok(output) = output {
        if output.status.success() {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let orphans: Vec<&str> = stdout.lines().collect();

            if orphans.len() >= 20 {
                insights.push(DiagnosticInsight {
                    rule_id: "orphan_packages_excessive".to_string(),
                    severity: DiagnosticSeverity::Warning,
                    summary: format!("{} orphaned packages found", orphans.len()),
                    details: format!(
                        "System has {} orphaned packages (no longer required by installed packages):\n\n\
                         Orphaned packages waste disk space and can be safely removed. \
                         Review the list and remove unneeded packages.\n\n\
                         Sample orphans: {}{}",
                        orphans.len(),
                        orphans.iter().take(10).copied().collect::<Vec<_>>().join(", "),
                        if orphans.len() > 10 { "..." } else { "" }
                    ),
                    commands: vec![
                        "pacman -Qdtq".to_string(),
                        "pacman -Qdt".to_string(),
                        "sudo pacman -Rns $(pacman -Qdtq)".to_string(),
                    ],
                    citations: vec![
                        "man pacman".to_string(),
                        "https://wiki.archlinux.org/title/Pacman#Removing_unused_packages_(orphans)".to_string(),
                    ],
                    evidence: format!("{} orphaned packages detected", orphans.len()),
                });
            }
        }
    }

    insights
}

/// Rule: Check for failed mount points (Beta.217b)
fn check_failed_mounts() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Check systemd mount units
    let output = std::process::Command::new("systemctl")
        .args(["list-units", "--type=mount", "--state=failed", "--no-legend", "--no-pager"])
        .output();

    if let Ok(output) = output {
        if output.status.success() {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let failed_mounts: Vec<&str> = stdout.lines().collect();

            if !failed_mounts.is_empty() {
                let mount_names: Vec<String> = failed_mounts
                    .iter()
                    .filter_map(|line| line.split_whitespace().next())
                    .map(|s| s.to_string())
                    .collect();

                insights.push(DiagnosticInsight {
                    rule_id: "failed_mounts".to_string(),
                    severity: DiagnosticSeverity::Critical,
                    summary: format!("{} mount point(s) failed", failed_mounts.len()),
                    details: format!(
                        "Failed mount points detected:\n\n{}\n\n\
                         Failed mounts can prevent access to filesystems and cause \
                         applications to malfunction. Check device availability and fstab configuration.",
                        mount_names.join("\n")
                    ),
                    commands: vec![
                        "systemctl list-units --type=mount --state=failed".to_string(),
                        "mount -l".to_string(),
                        "cat /etc/fstab".to_string(),
                        "lsblk -f".to_string(),
                    ],
                    citations: vec![
                        "man systemctl".to_string(),
                        "man fstab".to_string(),
                        "https://wiki.archlinux.org/title/Fstab".to_string(),
                    ],
                    evidence: format!("Failed mounts: {}", mount_names.join(", ")),
                });
            }
        }
    }

    insights
}

/// Format insights as canonical [SUMMARY]/[DETAILS]/[COMMANDS] output
pub fn format_insights(insights: &[DiagnosticInsight]) -> String {
    if insights.is_empty() {
        return format!(
            "[SUMMARY]\n\
             System health is good - no critical issues detected.\n\n\
             [DETAILS]\n\
             All monitored services are running normally, no critical log issues found.\n\n\
             [COMMANDS]\n\
             $ systemctl --failed\n\
             $ journalctl -p err -n 20 --no-pager\n"
        );
    }

    let mut output = String::new();

    // Summary section
    output.push_str("[SUMMARY]\n");
    let critical_count = insights
        .iter()
        .filter(|i| i.severity == DiagnosticSeverity::Critical)
        .count();
    let warning_count = insights
        .iter()
        .filter(|i| i.severity == DiagnosticSeverity::Warning)
        .count();

    if critical_count > 0 {
        output.push_str(&format!(
            "{} critical issue(s) detected requiring immediate attention.\n",
            critical_count
        ));
    }
    if warning_count > 0 {
        output.push_str(&format!(
            "{} warning(s) detected that should be investigated.\n",
            warning_count
        ));
    }
    output.push('\n');

    // Details section
    output.push_str("[DETAILS]\n");
    for (idx, insight) in insights.iter().enumerate() {
        let severity_label = match insight.severity {
            DiagnosticSeverity::Critical => "CRITICAL",
            DiagnosticSeverity::Warning => "WARNING",
            DiagnosticSeverity::Info => "INFO",
        };

        output.push_str(&format!(
            "**{}. [{}] {}**\n\n{}\n\n",
            idx + 1,
            severity_label,
            insight.summary,
            insight.details
        ));

        if !insight.evidence.is_empty() {
            output.push_str(&format!("Evidence: {}\n\n", insight.evidence));
        }
    }

    // Commands section
    output.push_str("[COMMANDS]\n");
    output.push_str("Diagnostic commands to investigate issues:\n\n");

    let mut all_commands = Vec::new();
    for insight in insights {
        for cmd in &insight.commands {
            if !all_commands.contains(cmd) {
                all_commands.push(cmd.clone());
            }
        }
    }

    for cmd in &all_commands {
        output.push_str(&format!("$ {}\n", cmd));
    }
    output.push('\n');

    // References section
    let mut all_citations = Vec::new();
    for insight in insights {
        for citation in &insight.citations {
            if !all_citations.contains(citation) {
                all_citations.push(citation.clone());
            }
        }
    }

    if !all_citations.is_empty() {
        output.push_str("**References:**\n");
        for citation in &all_citations {
            output.push_str(&format!("- {}\n", citation));
        }
    }

    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    #[test]
    fn test_failed_services_detection() {
        let health = HealthReport {
            timestamp: Utc::now(),
            overall_status: HealthStatus::Critical,
            services: vec![
                ServiceStatus {
                    name: "sshd.service".to_string(),
                    state: "failed".to_string(),
                    load: "loaded".to_string(),
                    sub: "failed".to_string(),
                    description: "OpenSSH Daemon".to_string(),
                },
            ],
            packages: vec![],
            log_issues: vec![],
            recommendations: vec![],
            message: "Test".to_string(),
            citation: "Test".to_string(),
        };

        let insights = analyze_system_health(&health);

        assert!(!insights.is_empty());
        assert!(insights
            .iter()
            .any(|i| i.rule_id == "failed_services"));

        let failed_insight = insights
            .iter()
            .find(|i| i.rule_id == "failed_services")
            .unwrap();
        assert_eq!(failed_insight.severity, DiagnosticSeverity::Critical);
        assert!(failed_insight.summary.contains("failed state"));
        assert!(!failed_insight.commands.is_empty());
    }

    #[test]
    fn test_healthy_system() {
        let health = HealthReport {
            timestamp: Utc::now(),
            overall_status: HealthStatus::Healthy,
            services: vec![
                ServiceStatus {
                    name: "sshd.service".to_string(),
                    state: "active".to_string(),
                    load: "loaded".to_string(),
                    sub: "running".to_string(),
                    description: "OpenSSH Daemon".to_string(),
                },
            ],
            packages: vec![],
            log_issues: vec![],
            recommendations: vec![],
            message: "All systems nominal".to_string(),
            citation: "Health check".to_string(),
        };

        let insights = analyze_system_health(&health);

        // Healthy system should produce no critical or warning insights
        assert!(insights
            .iter()
            .all(|i| i.severity != DiagnosticSeverity::Critical));
    }

    #[test]
    fn test_format_insights() {
        let insights = vec![DiagnosticInsight {
            rule_id: "test_rule".to_string(),
            severity: DiagnosticSeverity::Warning,
            summary: "Test issue detected".to_string(),
            details: "This is a test issue for formatting".to_string(),
            commands: vec!["systemctl status test".to_string()],
            citations: vec!["man systemctl".to_string()],
            evidence: "Test evidence".to_string(),
        }];

        let formatted = format_insights(&insights);

        assert!(formatted.contains("[SUMMARY]"));
        assert!(formatted.contains("[DETAILS]"));
        assert!(formatted.contains("[COMMANDS]"));
        assert!(formatted.contains("Test issue detected"));
        assert!(formatted.contains("systemctl status test"));
    }

    #[test]
    fn test_critical_log_issues() {
        let health = HealthReport {
            timestamp: Utc::now(),
            overall_status: HealthStatus::Degraded,
            services: vec![],
            packages: vec![],
            log_issues: vec![
                LogIssue {
                    severity: "error".to_string(),
                    message: "Disk I/O error".to_string(),
                    source: "kernel".to_string(),
                    first_seen: Utc::now(),
                    count: 5,
                },
            ],
            recommendations: vec![],
            message: "Log issues detected".to_string(),
            citation: "Journal analysis".to_string(),
        };

        let insights = analyze_system_health(&health);

        assert!(insights
            .iter()
            .any(|i| i.rule_id == "critical_log_issues"));
    }
}
