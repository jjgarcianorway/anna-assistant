//! Sysadmin Brain - Deterministic Systems Intelligence
//!
//! Beta.217a: Sysadmin Brain Foundation
//!
//! Pure logic-based diagnostic engine that interprets telemetry data
//! and generates actionable insights. No LLM inference - just deterministic rules
//! based on real system administration knowledge.
//!
//! Philosophy:
//! - Every insight backed by concrete telemetry evidence
//! - Every recommendation includes specific commands to run
//! - Every rule cites documentation (man pages, Arch Wiki)
//! - Zero hallucinations - if we don't know, we don't guess

use crate::steward::{HealthReport, HealthStatus, LogIssue, ServiceStatus};
use serde::{Deserialize, Serialize};

/// Severity level for diagnostic insights
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum DiagnosticSeverity {
    /// Informational - no action needed
    Info,
    /// Warning - should investigate
    Warning,
    /// Critical - requires immediate attention
    Critical,
}

/// A diagnostic insight generated by the sysadmin brain
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DiagnosticInsight {
    /// Unique identifier for this type of insight
    pub rule_id: String,

    /// Severity level
    pub severity: DiagnosticSeverity,

    /// Summary - one sentence describing the issue
    pub summary: String,

    /// Detailed explanation of what was detected
    pub details: String,

    /// Commands to diagnose or fix the issue
    pub commands: Vec<String>,

    /// Documentation citations (man pages, Arch Wiki URLs)
    pub citations: Vec<String>,

    /// Evidence from telemetry that triggered this rule
    pub evidence: String,
}

/// Analyze system health and generate diagnostic insights
///
/// This is the main entry point for the sysadmin brain. It takes a HealthReport
/// and runs all diagnostic rules, returning a list of insights.
pub fn analyze_system_health(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Run all diagnostic rules
    insights.extend(check_failed_services(health));
    insights.extend(check_degraded_services(health));
    insights.extend(check_log_issues(health));
    insights.extend(check_overall_health(health));

    // Beta.217b: Additional diagnostic rules
    insights.extend(check_disk_space());
    insights.extend(check_memory_pressure());
    insights.extend(check_cpu_usage());
    insights.extend(check_orphan_packages());
    insights.extend(check_failed_mounts());

    // Beta.267: Network diagnostics
    insights.extend(check_network_issues(health));

    insights
}

/// Rule: Detect failed systemd services
fn check_failed_services(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    let failed_services: Vec<&ServiceStatus> = health
        .services
        .iter()
        .filter(|s| s.state == "failed")
        .collect();

    if !failed_services.is_empty() {
        let service_names: Vec<&str> = failed_services
            .iter()
            .map(|s| s.name.as_str())
            .collect();

        let commands = vec![
            format!("systemctl status {}", service_names.join(" ")),
            format!("journalctl -u {} -n 50 --no-pager", service_names[0]),
        ];

        insights.push(DiagnosticInsight {
            rule_id: "failed_services".to_string(),
            severity: DiagnosticSeverity::Critical,
            summary: format!("{} systemd service(s) in failed state", failed_services.len()),
            details: format!(
                "The following services have failed: {}. Failed services indicate \
                 that system components are not running as expected and may impact \
                 system functionality.",
                service_names.join(", ")
            ),
            commands,
            citations: vec![
                "man systemctl".to_string(),
                "man journalctl".to_string(),
                "https://wiki.archlinux.org/title/Systemd#Using_units".to_string(),
            ],
            evidence: format!("Failed services detected: {}", service_names.join(", ")),
        });
    }

    insights
}

/// Rule: Detect degraded or inactive-dead services that should be running
fn check_degraded_services(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Services that are loaded but inactive-dead (not running but should be)
    let degraded_services: Vec<&ServiceStatus> = health
        .services
        .iter()
        .filter(|s| {
            s.state == "inactive" &&
            s.load == "loaded" &&
            s.sub == "dead" &&
            // Only flag important system services, not user services
            (s.name.contains("network") ||
             s.name.contains("bluetooth") ||
             s.name.contains("cups") ||
             s.name == "annad.service")
        })
        .collect();

    if !degraded_services.is_empty() {
        let service_names: Vec<&str> = degraded_services
            .iter()
            .map(|s| s.name.as_str())
            .collect();

        insights.push(DiagnosticInsight {
            rule_id: "degraded_services".to_string(),
            severity: DiagnosticSeverity::Warning,
            summary: format!("{} important service(s) loaded but not running", degraded_services.len()),
            details: format!(
                "The following important services are loaded but not currently running: {}. \
                 These services may need to be started for full system functionality.",
                service_names.join(", ")
            ),
            commands: vec![
                format!("systemctl is-enabled {}", service_names.join(" ")),
                format!("sudo systemctl start {}", service_names[0]),
            ],
            citations: vec![
                "man systemctl".to_string(),
                "https://wiki.archlinux.org/title/Systemd#Using_units".to_string(),
            ],
            evidence: format!("Inactive services: {}", service_names.join(", ")),
        });
    }

    insights
}

/// Rule: Detect critical log issues
fn check_log_issues(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Group log issues by severity
    let critical_issues: Vec<&LogIssue> = health
        .log_issues
        .iter()
        .filter(|issue| issue.severity == "critical" || issue.severity == "error")
        .collect();

    if !critical_issues.is_empty() {
        // Take the most frequent critical issue
        let top_issue = critical_issues
            .iter()
            .max_by_key(|issue| issue.count)
            .unwrap();

        insights.push(DiagnosticInsight {
            rule_id: "critical_log_issues".to_string(),
            severity: DiagnosticSeverity::Critical,
            summary: format!("{} critical log issue(s) detected", critical_issues.len()),
            details: format!(
                "System logs contain {} critical or error-level issues. \
                 Most frequent: \"{}\" from {} (seen {} times since {}).",
                critical_issues.len(),
                top_issue.message,
                top_issue.source,
                top_issue.count,
                top_issue.first_seen.format("%Y-%m-%d %H:%M")
            ),
            commands: vec![
                format!("journalctl -p err -n 20 --no-pager"),
                format!("journalctl -p crit -n 20 --no-pager"),
                format!("journalctl --since \"1 hour ago\" | grep -i error | head -20"),
            ],
            citations: vec![
                "man journalctl".to_string(),
                "https://wiki.archlinux.org/title/Systemd/Journal".to_string(),
            ],
            evidence: format!(
                "Critical issues: {} (most frequent: {} occurrences)",
                critical_issues.len(),
                top_issue.count
            ),
        });
    }

    insights
}

/// Rule: Overall health status assessment
fn check_overall_health(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    match health.overall_status {
        HealthStatus::Critical => {
            insights.push(DiagnosticInsight {
                rule_id: "overall_health_critical".to_string(),
                severity: DiagnosticSeverity::Critical,
                summary: "System health is critical".to_string(),
                details: format!(
                    "Overall system health assessment is CRITICAL. {}",
                    health.message
                ),
                commands: vec![
                    "systemctl --failed".to_string(),
                    "journalctl -p err -n 50 --no-pager".to_string(),
                    "df -h".to_string(),
                    "free -h".to_string(),
                ],
                citations: vec![
                    health.citation.clone(),
                ],
                evidence: format!("HealthStatus::Critical - {}", health.message),
            });
        }
        HealthStatus::Degraded => {
            insights.push(DiagnosticInsight {
                rule_id: "overall_health_degraded".to_string(),
                severity: DiagnosticSeverity::Warning,
                summary: "System health is degraded".to_string(),
                details: format!(
                    "Overall system health assessment is DEGRADED. {}",
                    health.message
                ),
                commands: vec![
                    "systemctl --failed".to_string(),
                    "journalctl -p warning -n 50 --no-pager".to_string(),
                ],
                citations: vec![
                    health.citation.clone(),
                ],
                evidence: format!("HealthStatus::Degraded - {}", health.message),
            });
        }
        HealthStatus::Healthy => {
            // Don't generate insight for healthy systems unless explicitly requested
        }
    }

    insights
}

/// Rule: Check disk space usage (Beta.217b)
fn check_disk_space() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Run df to check disk usage
    let output = std::process::Command::new("df")
        .args(["-h", "--output=source,size,used,avail,pcent,target"])
        .output();

    if let Ok(output) = output {
        if output.status.success() {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let mut critical_filesystems = Vec::new();
            let mut warning_filesystems = Vec::new();

            for line in stdout.lines().skip(1) {
                // Skip header
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 6 {
                    let device = parts[0];
                    let size = parts[1];
                    let used = parts[2];
                    let avail = parts[3];
                    let usage_str = parts[4];
                    let mount = parts[5];

                    // Parse usage percentage
                    if let Some(percent_str) = usage_str.strip_suffix('%') {
                        if let Ok(usage_percent) = percent_str.parse::<u32>() {
                            if usage_percent >= 90 {
                                critical_filesystems.push((mount, device, usage_percent, avail));
                            } else if usage_percent >= 80 {
                                warning_filesystems.push((mount, device, usage_percent, avail));
                            }
                        }
                    }
                }
            }

            // Critical disk space
            if !critical_filesystems.is_empty() {
                let fs_details: Vec<String> = critical_filesystems
                    .iter()
                    .map(|(mount, dev, pct, avail)| {
                        format!("{} ({}): {}% full, {} available", mount, dev, pct, avail)
                    })
                    .collect();

                insights.push(DiagnosticInsight {
                    rule_id: "disk_space_critical".to_string(),
                    severity: DiagnosticSeverity::Critical,
                    summary: format!("{} filesystem(s) critically low on space", critical_filesystems.len()),
                    details: format!(
                        "Critical disk space situation detected:\n\n{}\n\n\
                         Filesystems above 90% capacity can cause system instability, \
                         failed updates, and application crashes. Immediate cleanup required.",
                        fs_details.join("\n")
                    ),
                    commands: vec![
                        "df -h".to_string(),
                        "du -sh /* 2>/dev/null | sort -h | tail -20".to_string(),
                        "journalctl --disk-usage".to_string(),
                        "pacman -Sc".to_string(),
                    ],
                    citations: vec![
                        "man df".to_string(),
                        "man du".to_string(),
                        "https://wiki.archlinux.org/title/Pacman#Cleaning_the_package_cache".to_string(),
                    ],
                    evidence: format!("Critical filesystems: {}",
                        critical_filesystems.iter()
                            .map(|(m, _, p, _)| format!("{} ({}%)", m, p))
                            .collect::<Vec<_>>()
                            .join(", ")
                    ),
                });
            }

            // Warning disk space
            if !warning_filesystems.is_empty() && critical_filesystems.is_empty() {
                let fs_details: Vec<String> = warning_filesystems
                    .iter()
                    .map(|(mount, dev, pct, avail)| {
                        format!("{} ({}): {}% full, {} available", mount, dev, pct, avail)
                    })
                    .collect();

                insights.push(DiagnosticInsight {
                    rule_id: "disk_space_warning".to_string(),
                    severity: DiagnosticSeverity::Warning,
                    summary: format!("{} filesystem(s) low on space", warning_filesystems.len()),
                    details: format!(
                        "Disk space warning:\n\n{}\n\n\
                         Consider cleaning up old files, package cache, or logs before \
                         space becomes critical.",
                        fs_details.join("\n")
                    ),
                    commands: vec![
                        "df -h".to_string(),
                        "du -sh /var/cache/pacman/pkg".to_string(),
                        "journalctl --vacuum-time=30d".to_string(),
                    ],
                    citations: vec![
                        "man df".to_string(),
                        "https://wiki.archlinux.org/title/System_maintenance".to_string(),
                    ],
                    evidence: format!("Warning filesystems: {}",
                        warning_filesystems.iter()
                            .map(|(m, _, p, _)| format!("{} ({}%)", m, p))
                            .collect::<Vec<_>>()
                            .join(", ")
                    ),
                });
            }
        }
    }

    insights
}

/// Rule: Check memory pressure (Beta.217b)
fn check_memory_pressure() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Use sysinfo to check memory usage
    let mut sys = sysinfo::System::new_all();
    sys.refresh_memory();

    let total_mem = sys.total_memory();
    let used_mem = sys.used_memory();
    let available_mem = sys.available_memory();
    let swap_total = sys.total_swap();
    let swap_used = sys.used_swap();

    if total_mem > 0 {
        let mem_usage_percent = (used_mem as f64 / total_mem as f64 * 100.0) as u32;
        let swap_usage_percent = if swap_total > 0 {
            (swap_used as f64 / swap_total as f64 * 100.0) as u32
        } else {
            0
        };

        // Critical memory pressure: >95% used or heavy swap
        if mem_usage_percent >= 95 || swap_usage_percent >= 80 {
            insights.push(DiagnosticInsight {
                rule_id: "memory_pressure_critical".to_string(),
                severity: DiagnosticSeverity::Critical,
                summary: "Critical memory pressure detected".to_string(),
                details: format!(
                    "System is under severe memory pressure:\n\n\
                     - Physical RAM: {}% used ({} MB / {} MB)\n\
                     - Available: {} MB\n\
                     - Swap: {}% used ({} MB / {} MB)\n\n\
                     High memory usage can cause system slowdowns, OOM killer activation, \
                     and application crashes. Identify and stop memory-intensive processes.",
                    mem_usage_percent,
                    used_mem / 1024 / 1024,
                    total_mem / 1024 / 1024,
                    available_mem / 1024 / 1024,
                    swap_usage_percent,
                    swap_used / 1024 / 1024,
                    swap_total / 1024 / 1024
                ),
                commands: vec![
                    "free -h".to_string(),
                    "ps aux --sort=-%mem | head -20".to_string(),
                    "systemd-cgtop -n 1 -m".to_string(),
                    "journalctl -k | grep -i 'out of memory'".to_string(),
                ],
                citations: vec![
                    "man free".to_string(),
                    "man ps".to_string(),
                    "https://wiki.archlinux.org/title/Improving_performance#Memory".to_string(),
                ],
                evidence: format!(
                    "Memory {}% used, Swap {}% used",
                    mem_usage_percent, swap_usage_percent
                ),
            });
        }
        // Warning: >85% memory usage
        else if mem_usage_percent >= 85 {
            insights.push(DiagnosticInsight {
                rule_id: "memory_pressure_warning".to_string(),
                severity: DiagnosticSeverity::Warning,
                summary: "High memory usage detected".to_string(),
                details: format!(
                    "Memory usage is elevated:\n\n\
                     - Physical RAM: {}% used ({} MB / {} MB)\n\
                     - Available: {} MB\n\n\
                     Consider closing unused applications or investigating memory leaks.",
                    mem_usage_percent,
                    used_mem / 1024 / 1024,
                    total_mem / 1024 / 1024,
                    available_mem / 1024 / 1024
                ),
                commands: vec![
                    "free -h".to_string(),
                    "ps aux --sort=-%mem | head -10".to_string(),
                ],
                citations: vec![
                    "man free".to_string(),
                    "https://wiki.archlinux.org/title/System_maintenance".to_string(),
                ],
                evidence: format!("Memory {}% used", mem_usage_percent),
            });
        }
    }

    insights
}

/// Rule: Check CPU usage patterns (Beta.217b)
fn check_cpu_usage() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Read load average
    if let Ok(loadavg_str) = std::fs::read_to_string("/proc/loadavg") {
        let parts: Vec<&str> = loadavg_str.split_whitespace().collect();
        if parts.len() >= 3 {
            if let (Ok(load1), Ok(load5), Ok(load15)) = (
                parts[0].parse::<f64>(),
                parts[1].parse::<f64>(),
                parts[2].parse::<f64>(),
            ) {
                // Get CPU count
                let cpu_count = num_cpus::get() as f64;

                // Load average above CPU count indicates saturation
                let normalized_load1 = load1 / cpu_count;
                let normalized_load5 = load5 / cpu_count;
                let normalized_load15 = load15 / cpu_count;

                // Critical: sustained high load across all intervals
                if normalized_load1 > 2.0 && normalized_load5 > 1.5 && normalized_load15 > 1.0 {
                    insights.push(DiagnosticInsight {
                        rule_id: "cpu_overload_critical".to_string(),
                        severity: DiagnosticSeverity::Critical,
                        summary: "Critical CPU overload detected".to_string(),
                        details: format!(
                            "System is experiencing sustained CPU overload:\n\n\
                             - Load averages: {:.2}, {:.2}, {:.2} (1m, 5m, 15m)\n\
                             - CPU cores: {}\n\
                             - Normalized load: {:.2}, {:.2}, {:.2}\n\n\
                             Sustained high load can cause system unresponsiveness and \
                             application timeouts. Identify CPU-intensive processes.",
                            load1, load5, load15, cpu_count as u32,
                            normalized_load1, normalized_load5, normalized_load15
                        ),
                        commands: vec![
                            "uptime".to_string(),
                            "ps aux --sort=-%cpu | head -20".to_string(),
                            "systemd-cgtop -n 1 -c".to_string(),
                            "top -b -n 1 | head -20".to_string(),
                        ],
                        citations: vec![
                            "man uptime".to_string(),
                            "man top".to_string(),
                            "https://wiki.archlinux.org/title/Improving_performance#CPU".to_string(),
                        ],
                        evidence: format!(
                            "Load averages {:.2}/{:.2}/{:.2} on {} cores",
                            load1, load5, load15, cpu_count as u32
                        ),
                    });
                }
                // Warning: elevated load
                else if normalized_load5 > 1.2 {
                    insights.push(DiagnosticInsight {
                        rule_id: "cpu_high_load".to_string(),
                        severity: DiagnosticSeverity::Warning,
                        summary: "Elevated CPU load detected".to_string(),
                        details: format!(
                            "CPU load is elevated:\n\n\
                             - Load averages: {:.2}, {:.2}, {:.2} (1m, 5m, 15m)\n\
                             - CPU cores: {}\n\n\
                             System may be running intensive workloads.",
                            load1, load5, load15, cpu_count as u32
                        ),
                        commands: vec![
                            "uptime".to_string(),
                            "ps aux --sort=-%cpu | head -10".to_string(),
                        ],
                        citations: vec!["man uptime".to_string()],
                        evidence: format!("5-min load {:.2} on {} cores", load5, cpu_count as u32),
                    });
                }
            }
        }
    }

    insights
}

/// Rule: Check for orphaned packages (Beta.217b)
fn check_orphan_packages() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Check for orphaned packages
    let output = std::process::Command::new("pacman")
        .args(["-Qdtq"])
        .output();

    if let Ok(output) = output {
        if output.status.success() {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let orphans: Vec<&str> = stdout.lines().collect();

            if orphans.len() >= 20 {
                insights.push(DiagnosticInsight {
                    rule_id: "orphan_packages_excessive".to_string(),
                    severity: DiagnosticSeverity::Warning,
                    summary: format!("{} orphaned packages found", orphans.len()),
                    details: format!(
                        "System has {} orphaned packages (no longer required by installed packages):\n\n\
                         Orphaned packages waste disk space and can be safely removed. \
                         Review the list and remove unneeded packages.\n\n\
                         Sample orphans: {}{}",
                        orphans.len(),
                        orphans.iter().take(10).copied().collect::<Vec<_>>().join(", "),
                        if orphans.len() > 10 { "..." } else { "" }
                    ),
                    commands: vec![
                        "pacman -Qdtq".to_string(),
                        "pacman -Qdt".to_string(),
                        "sudo pacman -Rns $(pacman -Qdtq)".to_string(),
                    ],
                    citations: vec![
                        "man pacman".to_string(),
                        "https://wiki.archlinux.org/title/Pacman#Removing_unused_packages_(orphans)".to_string(),
                    ],
                    evidence: format!("{} orphaned packages detected", orphans.len()),
                });
            }
        }
    }

    insights
}

/// Rule: Check for failed mount points (Beta.217b)
fn check_failed_mounts() -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    // Check systemd mount units
    let output = std::process::Command::new("systemctl")
        .args(["list-units", "--type=mount", "--state=failed", "--no-legend", "--no-pager"])
        .output();

    if let Ok(output) = output {
        if output.status.success() {
            let stdout = String::from_utf8_lossy(&output.stdout);
            let failed_mounts: Vec<&str> = stdout.lines().collect();

            if !failed_mounts.is_empty() {
                let mount_names: Vec<String> = failed_mounts
                    .iter()
                    .filter_map(|line| line.split_whitespace().next())
                    .map(|s| s.to_string())
                    .collect();

                insights.push(DiagnosticInsight {
                    rule_id: "failed_mounts".to_string(),
                    severity: DiagnosticSeverity::Critical,
                    summary: format!("{} mount point(s) failed", failed_mounts.len()),
                    details: format!(
                        "Failed mount points detected:\n\n{}\n\n\
                         Failed mounts can prevent access to filesystems and cause \
                         applications to malfunction. Check device availability and fstab configuration.",
                        mount_names.join("\n")
                    ),
                    commands: vec![
                        "systemctl list-units --type=mount --state=failed".to_string(),
                        "mount -l".to_string(),
                        "cat /etc/fstab".to_string(),
                        "lsblk -f".to_string(),
                    ],
                    citations: vec![
                        "man systemctl".to_string(),
                        "man fstab".to_string(),
                        "https://wiki.archlinux.org/title/Fstab".to_string(),
                    ],
                    evidence: format!("Failed mounts: {}", mount_names.join(", ")),
                });
            }
        }
    }

    insights
}

/// Format insights as canonical [SUMMARY]/[DETAILS]/[COMMANDS] output
pub fn format_insights(insights: &[DiagnosticInsight]) -> String {
    if insights.is_empty() {
        return format!(
            "[SUMMARY]\n\
             System health is good - no critical issues detected.\n\n\
             [DETAILS]\n\
             All monitored services are running normally, no critical log issues found.\n\n\
             [COMMANDS]\n\
             $ systemctl --failed\n\
             $ journalctl -p err -n 20 --no-pager\n"
        );
    }

    let mut output = String::new();

    // Summary section
    output.push_str("[SUMMARY]\n");
    let critical_count = insights
        .iter()
        .filter(|i| i.severity == DiagnosticSeverity::Critical)
        .count();
    let warning_count = insights
        .iter()
        .filter(|i| i.severity == DiagnosticSeverity::Warning)
        .count();

    if critical_count > 0 {
        output.push_str(&format!(
            "{} critical issue(s) detected requiring immediate attention.\n",
            critical_count
        ));
    }
    if warning_count > 0 {
        output.push_str(&format!(
            "{} warning(s) detected that should be investigated.\n",
            warning_count
        ));
    }
    output.push('\n');

    // Details section
    output.push_str("[DETAILS]\n");
    for (idx, insight) in insights.iter().enumerate() {
        let severity_label = match insight.severity {
            DiagnosticSeverity::Critical => "CRITICAL",
            DiagnosticSeverity::Warning => "WARNING",
            DiagnosticSeverity::Info => "INFO",
        };

        output.push_str(&format!(
            "**{}. [{}] {}**\n\n{}\n\n",
            idx + 1,
            severity_label,
            insight.summary,
            insight.details
        ));

        if !insight.evidence.is_empty() {
            output.push_str(&format!("Evidence: {}\n\n", insight.evidence));
        }
    }

    // Commands section
    output.push_str("[COMMANDS]\n");
    output.push_str("Diagnostic commands to investigate issues:\n\n");

    let mut all_commands = Vec::new();
    for insight in insights {
        for cmd in &insight.commands {
            if !all_commands.contains(cmd) {
                all_commands.push(cmd.clone());
            }
        }
    }

    for cmd in &all_commands {
        output.push_str(&format!("$ {}\n", cmd));
    }
    output.push('\n');

    // References section
    let mut all_citations = Vec::new();
    for insight in insights {
        for citation in &insight.citations {
            if !all_citations.contains(citation) {
                all_citations.push(citation.clone());
            }
        }
    }

    if !all_citations.is_empty() {
        output.push_str("**References:**\n");
        for citation in &all_citations {
            output.push_str(&format!("- {}\n", citation));
        }
    }

    output
}

/// Beta.267: Rule: Detect network interface conflicts and connectivity issues
///
/// Detects:
/// - Slow Ethernet taking priority over fast WiFi
/// - Duplicate default routes
/// - High packet loss or latency
/// - Interface priority mismatches
fn check_network_issues(health: &HealthReport) -> Vec<DiagnosticInsight> {
    let mut insights = Vec::new();

    let Some(ref net) = health.network_monitoring else {
        return insights; // No network data available
    };

    // Check for multi-interface conflicts (Ethernet vs WiFi)
    let ethernet_interfaces: Vec<_> = net.interfaces.iter()
        .filter(|i| matches!(i.interface_type, anna_common::network_monitoring::InterfaceType::Ethernet) && i.is_up)
        .collect();
    let wifi_interfaces: Vec<_> = net.interfaces.iter()
        .filter(|i| matches!(i.interface_type, anna_common::network_monitoring::InterfaceType::WiFi) && i.is_up)
        .collect();

    // Check for slow Ethernet outranking fast WiFi
    if !ethernet_interfaces.is_empty() && !wifi_interfaces.is_empty() {
        for eth in &ethernet_interfaces {
            for wifi in &wifi_interfaces {
                if let (Some(eth_speed), Some(wifi_speed)) = (eth.speed_mbps, wifi.speed_mbps) {
                    // If Ethernet is slower than WiFi but has default route, that's a problem
                    if eth_speed < wifi_speed {
                        // Check which interface has default route
                        let eth_has_default = net.routes.iter().any(|r| r.destination == "default" && r.interface == eth.name);
                        let wifi_has_default = net.routes.iter().any(|r| r.destination == "default" && r.interface == wifi.name);

                        if eth_has_default && !wifi_has_default {
                            insights.push(DiagnosticInsight {
                                rule_id: "network_priority_mismatch".to_string(),
                                severity: DiagnosticSeverity::Critical,
                                summary: format!("Slow Ethernet ({} Mbps) taking priority over faster WiFi ({} Mbps)", eth_speed, wifi_speed),
                                details: format!(
                                    "Interface {} (Ethernet, {} Mbps) is currently taking routing priority over {} (WiFi, {} Mbps). \
                                     This will result in degraded network performance. The faster WiFi connection should be preferred.",
                                    eth.name, eth_speed, wifi.name, wifi_speed
                                ),
                                commands: vec![
                                    "ip route show".to_string(),
                                    format!("ethtool {}", eth.name),
                                    "nmcli device show".to_string(),
                                    format!("nmcli device disconnect {}", eth.name),
                                ],
                                citations: vec![
                                    "man ip-route".to_string(),
                                    "man ethtool".to_string(),
                                    "https://wiki.archlinux.org/title/Network_configuration".to_string(),
                                ],
                                evidence: format!("Ethernet {} ({} Mbps) has default route, WiFi {} ({} Mbps) does not",
                                    eth.name, eth_speed, wifi.name, wifi_speed),
                            });
                        }
                    }
                }
            }
        }
    }

    // Check for duplicate default routes
    let default_routes: Vec<_> = net.routes.iter()
        .filter(|r| r.destination == "default" || r.destination == "0.0.0.0/0")
        .collect();

    if default_routes.len() > 1 {
        let interface_names: Vec<&str> = default_routes.iter().map(|r| r.interface.as_str()).collect();
        insights.push(DiagnosticInsight {
            rule_id: "duplicate_default_routes".to_string(),
            severity: DiagnosticSeverity::Critical,
            summary: format!("{} duplicate default routes detected", default_routes.len()),
            details: format!(
                "Multiple default routes exist on interfaces: {}. \
                 This can cause unpredictable routing behavior and connection failures. \
                 Only one default route should be active at a time.",
                interface_names.join(", ")
            ),
            commands: vec![
                "ip route show".to_string(),
                "nmcli connection show --active".to_string(),
            ],
            citations: vec![
                "man ip-route".to_string(),
                "https://wiki.archlinux.org/title/Network_configuration#Routing_table".to_string(),
            ],
            evidence: format!("Default routes on: {}", interface_names.join(", ")),
        });
    }

    // Check for high packet loss
    if let Some(loss_pct) = net.packet_loss.internet_loss_percent {
        if loss_pct > 30.0 {
            insights.push(DiagnosticInsight {
                rule_id: "high_packet_loss".to_string(),
                severity: DiagnosticSeverity::Critical,
                summary: format!("Critical packet loss detected ({:.1}%)", loss_pct),
                details: format!(
                    "Internet connectivity shows {:.1}% packet loss, which is critically high. \
                     Normal connections should have less than 1% packet loss. \
                     This indicates severe network problems.",
                    loss_pct
                ),
                commands: vec![
                    "ping -c 10 8.8.8.8".to_string(),
                    "ping -c 10 $(ip route | grep default | awk '{print $3}')".to_string(),
                ],
                citations: vec![
                    "man ping".to_string(),
                ],
                evidence: format!("{:.1}% packet loss", loss_pct),
            });
        } else if loss_pct > 10.0 {
            insights.push(DiagnosticInsight {
                rule_id: "elevated_packet_loss".to_string(),
                severity: DiagnosticSeverity::Warning,
                summary: format!("Elevated packet loss detected ({:.1}%)", loss_pct),
                details: format!(
                    "Internet connectivity shows {:.1}% packet loss. \
                     While not critical, this may cause noticeable performance degradation.",
                    loss_pct
                ),
                commands: vec![
                    "ping -c 10 8.8.8.8".to_string(),
                ],
                citations: vec!["man ping".to_string()],
                evidence: format!("{:.1}% packet loss", loss_pct),
            });
        }
    }

    // Check for high latency
    if let Some(latency_ms) = net.latency.internet_latency_ms {
        if latency_ms > 500.0 {
            insights.push(DiagnosticInsight {
                rule_id: "critical_latency".to_string(),
                severity: DiagnosticSeverity::Critical,
                summary: format!("Critical network latency ({:.0}ms)", latency_ms),
                details: format!(
                    "Internet latency is {:.0}ms, which is critically high. \
                     Normal latency should be under 100ms for most connections.",
                    latency_ms
                ),
                commands: vec![
                    "ping -c 5 8.8.8.8".to_string(),
                ],
                citations: vec!["man ping".to_string()],
                evidence: format!("{:.0}ms latency", latency_ms),
            });
        } else if latency_ms > 200.0 {
            insights.push(DiagnosticInsight {
                rule_id: "high_latency".to_string(),
                severity: DiagnosticSeverity::Warning,
                summary: format!("Elevated network latency ({:.0}ms)", latency_ms),
                details: format!(
                    "Internet latency is {:.0}ms, which is higher than optimal. \
                     This may cause sluggish network performance.",
                    latency_ms
                ),
                commands: vec![
                    "ping -c 5 8.8.8.8".to_string(),
                ],
                citations: vec!["man ping".to_string()],
                evidence: format!("{:.0}ms latency", latency_ms),
            });
        }
    }

    insights
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    #[test]
    fn test_failed_services_detection() {
        let health = HealthReport {
            timestamp: Utc::now(),
            overall_status: HealthStatus::Critical,
            services: vec![
                ServiceStatus {
                    name: "sshd.service".to_string(),
                    state: "failed".to_string(),
                    load: "loaded".to_string(),
                    sub: "failed".to_string(),
                    description: "OpenSSH Daemon".to_string(),
                },
            ],
            packages: vec![],
            log_issues: vec![],
            network_monitoring: None,
            recommendations: vec![],
            message: "Test".to_string(),
            citation: "Test".to_string(),
        };

        let insights = analyze_system_health(&health);

        assert!(!insights.is_empty());
        assert!(insights
            .iter()
            .any(|i| i.rule_id == "failed_services"));

        let failed_insight = insights
            .iter()
            .find(|i| i.rule_id == "failed_services")
            .unwrap();
        assert_eq!(failed_insight.severity, DiagnosticSeverity::Critical);
        assert!(failed_insight.summary.contains("failed state"));
        assert!(!failed_insight.commands.is_empty());
    }

    #[test]
    #[ignore] // Test calls actual system commands (df) - skipping for CI
    fn test_healthy_system() {
        let health = HealthReport {
            timestamp: Utc::now(),
            overall_status: HealthStatus::Healthy,
            services: vec![
                ServiceStatus {
                    name: "sshd.service".to_string(),
                    state: "active".to_string(),
                    load: "loaded".to_string(),
                    sub: "running".to_string(),
                    description: "OpenSSH Daemon".to_string(),
                },
            ],
            packages: vec![],
            log_issues: vec![],
            network_monitoring: None,
            recommendations: vec![],
            message: "All systems nominal".to_string(),
            citation: "Health check".to_string(),
        };

        let insights = analyze_system_health(&health);

        // Healthy system should produce no critical or warning insights
        assert!(insights
            .iter()
            .all(|i| i.severity != DiagnosticSeverity::Critical));
    }

    #[test]
    fn test_format_insights() {
        let insights = vec![DiagnosticInsight {
            rule_id: "test_rule".to_string(),
            severity: DiagnosticSeverity::Warning,
            summary: "Test issue detected".to_string(),
            details: "This is a test issue for formatting".to_string(),
            commands: vec!["systemctl status test".to_string()],
            citations: vec!["man systemctl".to_string()],
            evidence: "Test evidence".to_string(),
        }];

        let formatted = format_insights(&insights);

        assert!(formatted.contains("[SUMMARY]"));
        assert!(formatted.contains("[DETAILS]"));
        assert!(formatted.contains("[COMMANDS]"));
        assert!(formatted.contains("Test issue detected"));
        assert!(formatted.contains("systemctl status test"));
    }

    #[test]
    fn test_critical_log_issues() {
        let health = HealthReport {
            timestamp: Utc::now(),
            overall_status: HealthStatus::Degraded,
            services: vec![],
            packages: vec![],
            log_issues: vec![
                LogIssue {
                    severity: "error".to_string(),
                    message: "Disk I/O error".to_string(),
                    source: "kernel".to_string(),
                    first_seen: Utc::now(),
                    count: 5,
                },
            ],
            network_monitoring: None,
            recommendations: vec![],
            message: "Log issues detected".to_string(),
            citation: "Journal analysis".to_string(),
        };

        let insights = analyze_system_health(&health);

        assert!(insights
            .iter()
            .any(|i| i.rule_id == "critical_log_issues"));
    }

    #[test]
    fn test_network_priority_mismatch_detected() {
        use anna_common::network_monitoring::*;

        // Create slow Ethernet + fast WiFi scenario
        let eth = NetworkInterface {
            name: "eth0".to_string(),
            interface_type: InterfaceType::Ethernet,
            is_up: true,
            mac_address: Some("00:11:22:33:44:55".to_string()),
            ipv4_addresses: vec!["192.168.1.100/24".to_string()],
            ipv6_addresses: vec![],
            mtu: Some(1500),
            speed_mbps: Some(100), // Slow Ethernet
            config_method: AddressConfig::DHCP,
            stats: InterfaceStats {
                rx_bytes: 1000,
                rx_packets: 10,
                rx_errors: 0,
                rx_dropped: 0,
                tx_bytes: 500,
                tx_packets: 5,
                tx_errors: 0,
                tx_dropped: 0,
            },
        };

        let wifi = NetworkInterface {
            name: "wlan0".to_string(),
            interface_type: InterfaceType::WiFi,
            is_up: true,
            mac_address: Some("AA:BB:CC:DD:EE:FF".to_string()),
            ipv4_addresses: vec!["192.168.1.101/24".to_string()],
            ipv6_addresses: vec![],
            mtu: Some(1500),
            speed_mbps: Some(866), // Fast WiFi
            config_method: AddressConfig::DHCP,
            stats: InterfaceStats {
                rx_bytes: 5000,
                rx_packets: 50,
                rx_errors: 0,
                rx_dropped: 0,
                tx_bytes: 2500,
                tx_packets: 25,
                tx_errors: 0,
                tx_dropped: 0,
            },
        };

        // Ethernet has default route (wrong!)
        let route = Route {
            destination: "default".to_string(),
            gateway: Some("192.168.1.1".to_string()),
            interface: "eth0".to_string(),
            metric: Some(100),
            protocol: Some("dhcp".to_string()),
        };

        let network_monitoring = Some(NetworkMonitoring {
            interfaces: vec![eth, wifi],
            ipv4_status: IpVersionStatus {
                enabled: true,
                has_connectivity: true,
                default_gateway: Some("192.168.1.1".to_string()),
                address_count: 2,
            },
            ipv6_status: IpVersionStatus {
                enabled: false,
                has_connectivity: false,
                default_gateway: None,
                address_count: 0,
            },
            dnssec_status: DnssecStatus {
                enabled: false,
                resolver: None,
                validation_mode: None,
            },
            latency: LatencyMetrics {
                gateway_latency_ms: Some(1.0),
                dns_latency_ms: None,
                internet_latency_ms: Some(50.0),
                measurement_successful: true,
            },
            packet_loss: PacketLossStats {
                gateway_loss_percent: None,
                dns_loss_percent: None,
                internet_loss_percent: None,
                measurement_successful: true,
            },
            routes: vec![route],
            firewall_rules: FirewallRules {
                firewall_type: Some("nftables".to_string()),
                is_active: true,
                rule_count: 10,
                default_input_policy: Some("DROP".to_string()),
                default_output_policy: Some("ACCEPT".to_string()),
                default_forward_policy: Some("DROP".to_string()),
                open_ports: vec![],
            },
        });

        let health = HealthReport {
            timestamp: Utc::now(),
            overall_status: crate::steward::HealthStatus::Healthy,
            services: vec![],
            packages: vec![],
            log_issues: vec![],
            network_monitoring,
            recommendations: vec![],
            message: "OK".to_string(),
            citation: "Test".to_string(),
        };

        let insights = analyze_system_health(&health);

        // Should detect network priority mismatch
        let network_insight = insights.iter().find(|i| i.rule_id == "network_priority_mismatch");
        assert!(network_insight.is_some(), "Network priority mismatch should be detected");

        let insight = network_insight.unwrap();
        assert_eq!(insight.severity, DiagnosticSeverity::Critical);
        assert!(insight.summary.contains("100 Mbps"));
        assert!(insight.summary.contains("866 Mbps"));
        assert!(!insight.evidence.contains("::"), "Evidence must not contain Rust enum syntax");
    }

    #[test]
    fn test_duplicate_default_routes_detected() {
        use anna_common::network_monitoring::*;

        let eth = NetworkInterface {
            name: "eth0".to_string(),
            interface_type: InterfaceType::Ethernet,
            is_up: true,
            mac_address: Some("00:11:22:33:44:55".to_string()),
            ipv4_addresses: vec!["192.168.1.100/24".to_string()],
            ipv6_addresses: vec![],
            mtu: Some(1500),
            speed_mbps: Some(1000),
            config_method: AddressConfig::DHCP,
            stats: InterfaceStats {
                rx_bytes: 1000,
                rx_packets: 10,
                rx_errors: 0,
                rx_dropped: 0,
                tx_bytes: 500,
                tx_packets: 5,
                tx_errors: 0,
                tx_dropped: 0,
            },
        };

        let wifi = NetworkInterface {
            name: "wlan0".to_string(),
            interface_type: InterfaceType::WiFi,
            is_up: true,
            mac_address: Some("AA:BB:CC:DD:EE:FF".to_string()),
            ipv4_addresses: vec!["192.168.1.101/24".to_string()],
            ipv6_addresses: vec![],
            mtu: Some(1500),
            speed_mbps: Some(866),
            config_method: AddressConfig::DHCP,
            stats: InterfaceStats {
                rx_bytes: 5000,
                rx_packets: 50,
                rx_errors: 0,
                rx_dropped: 0,
                tx_bytes: 2500,
                tx_packets: 25,
                tx_errors: 0,
                tx_dropped: 0,
            },
        };

        // Both have default routes (bad!)
        let routes = vec![
            Route {
                destination: "default".to_string(),
                gateway: Some("192.168.1.1".to_string()),
                interface: "eth0".to_string(),
                metric: Some(100),
                protocol: Some("dhcp".to_string()),
            },
            Route {
                destination: "default".to_string(),
                gateway: Some("192.168.1.1".to_string()),
                interface: "wlan0".to_string(),
                metric: Some(200),
                protocol: Some("dhcp".to_string()),
            },
        ];

        let network_monitoring = Some(NetworkMonitoring {
            interfaces: vec![eth, wifi],
            ipv4_status: IpVersionStatus {
                enabled: true,
                has_connectivity: true,
                default_gateway: Some("192.168.1.1".to_string()),
                address_count: 2,
            },
            ipv6_status: IpVersionStatus {
                enabled: false,
                has_connectivity: false,
                default_gateway: None,
                address_count: 0,
            },
            dnssec_status: DnssecStatus {
                enabled: false,
                resolver: None,
                validation_mode: None,
            },
            latency: LatencyMetrics {
                gateway_latency_ms: Some(1.0),
                dns_latency_ms: None,
                internet_latency_ms: Some(50.0),
                measurement_successful: true,
            },
            packet_loss: PacketLossStats {
                gateway_loss_percent: None,
                dns_loss_percent: None,
                internet_loss_percent: None,
                measurement_successful: true,
            },
            routes,
            firewall_rules: FirewallRules {
                firewall_type: Some("nftables".to_string()),
                is_active: true,
                rule_count: 10,
                default_input_policy: Some("DROP".to_string()),
                default_output_policy: Some("ACCEPT".to_string()),
                default_forward_policy: Some("DROP".to_string()),
                open_ports: vec![],
            },
        });

        let health = HealthReport {
            timestamp: Utc::now(),
            overall_status: crate::steward::HealthStatus::Healthy,
            services: vec![],
            packages: vec![],
            log_issues: vec![],
            network_monitoring,
            recommendations: vec![],
            message: "OK".to_string(),
            citation: "Test".to_string(),
        };

        let insights = analyze_system_health(&health);

        // Should detect duplicate default routes
        let network_insight = insights.iter().find(|i| i.rule_id == "duplicate_default_routes");
        assert!(network_insight.is_some(), "Duplicate default routes should be detected");

        let insight = network_insight.unwrap();
        assert_eq!(insight.severity, DiagnosticSeverity::Critical);
        assert!(insight.summary.contains("2 duplicate default routes"));
    }

    #[test]
    fn test_high_packet_loss_detected() {
        use anna_common::network_monitoring::*;

        let wifi = NetworkInterface {
            name: "wlan0".to_string(),
            interface_type: InterfaceType::WiFi,
            is_up: true,
            mac_address: Some("AA:BB:CC:DD:EE:FF".to_string()),
            ipv4_addresses: vec!["192.168.1.101/24".to_string()],
            ipv6_addresses: vec![],
            mtu: Some(1500),
            speed_mbps: Some(300),
            config_method: AddressConfig::DHCP,
            stats: InterfaceStats {
                rx_bytes: 5000,
                rx_packets: 50,
                rx_errors: 0,
                rx_dropped: 0,
                tx_bytes: 2500,
                tx_packets: 25,
                tx_errors: 0,
                tx_dropped: 0,
            },
        };

        let network_monitoring = Some(NetworkMonitoring {
            interfaces: vec![wifi],
            ipv4_status: IpVersionStatus {
                enabled: true,
                has_connectivity: true,
                default_gateway: Some("192.168.1.1".to_string()),
                address_count: 1,
            },
            ipv6_status: IpVersionStatus {
                enabled: false,
                has_connectivity: false,
                default_gateway: None,
                address_count: 0,
            },
            dnssec_status: DnssecStatus {
                enabled: false,
                resolver: None,
                validation_mode: None,
            },
            latency: LatencyMetrics {
                gateway_latency_ms: Some(1.0),
                dns_latency_ms: None,
                internet_latency_ms: Some(50.0),
                measurement_successful: true,
            },
            packet_loss: PacketLossStats {
                gateway_loss_percent: None,
                dns_loss_percent: None,
                internet_loss_percent: Some(35.0), // Critical packet loss!
                measurement_successful: true,
            },
            routes: vec![Route {
                destination: "default".to_string(),
                gateway: Some("192.168.1.1".to_string()),
                interface: "wlan0".to_string(),
                metric: Some(100),
                protocol: Some("dhcp".to_string()),
            }],
            firewall_rules: FirewallRules {
                firewall_type: Some("nftables".to_string()),
                is_active: true,
                rule_count: 10,
                default_input_policy: Some("DROP".to_string()),
                default_output_policy: Some("ACCEPT".to_string()),
                default_forward_policy: Some("DROP".to_string()),
                open_ports: vec![],
            },
        });

        let health = HealthReport {
            timestamp: Utc::now(),
            overall_status: crate::steward::HealthStatus::Healthy,
            services: vec![],
            packages: vec![],
            log_issues: vec![],
            network_monitoring,
            recommendations: vec![],
            message: "OK".to_string(),
            citation: "Test".to_string(),
        };

        let insights = analyze_system_health(&health);

        // Should detect high packet loss
        let network_insight = insights.iter().find(|i| i.rule_id == "high_packet_loss");
        assert!(network_insight.is_some(), "High packet loss should be detected");

        let insight = network_insight.unwrap();
        assert_eq!(insight.severity, DiagnosticSeverity::Critical);
        assert!(insight.summary.contains("35"));
    }
}
