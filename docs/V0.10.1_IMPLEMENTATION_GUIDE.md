# Anna v0.10.1 Implementation Guide - Pure Telemetry Observer

## Executive Summary

This document provides a complete implementation plan for transforming Anna into a pure telemetry observer system with exactly 7 CLI commands, no actuation, and beautiful output.

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         annactl (CLI)                        â”‚
â”‚  7 commands: version status sensors net disk top radar exportâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚ UNIX Socket RPC
                 â”‚ /run/anna/annad.sock
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      annad (daemon)                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Telemetry Loop â”‚  â”‚  RPC Server   â”‚  â”‚  Storage Mgr  â”‚ â”‚
â”‚  â”‚  30s Â±5s jitterâ”‚â”€â”€â–¶â”‚  JSON-RPC 2.0 â”‚â”€â”€â–¶â”‚  SQLite + Ringâ”‚ â”‚
â”‚  â”‚  <0.5% CPU     â”‚  â”‚  Unix Socket  â”‚  â”‚  60 samples   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚         Persona Radar (internal classification)        â”‚ â”‚
â”‚  â”‚    8 scores: Minimalist, PowerUser, Server, etc.      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
        /var/lib/anna/telemetry.db
        (SQLite, 60-sample ring buffer)
```

## Current Status

### âœ“ Complete Modules
1. **telemetry_v10.rs** - Full system metrics collection with privacy redaction
2. **storage_v10.rs** - SQLite persistence with ring buffer
3. **main_v10.rs** (daemon) - Main loop with jitter and backoff
4. **persona_v10.rs** - 8-radar scoring system (partial)

### âš  Incomplete Modules
1. **rpc_v10.rs** - Needs 7 method handlers (status, sensors, net, disk, top, radar, export)
2. **main_v10.rs** (CLI) - Created, needs integration
3. **Systemd unit** - Not created
4. **Installer/Uninstaller** - Not created
5. **Makefile** - Not created

## Implementation Steps

### Step 1: Complete RPC Handlers (rpc_v10.rs)

Add these methods to the RPC server:

```rust
async fn method_status(&self, _params: &Option<Value>) -> Result<Value> {
    let storage = self.storage.lock().await;
    let latest = storage.get_latest_snapshot();

    let (last_sample_age_s, sample_count) = if let Some(snap) = latest {
        let now = SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs();
        let age = now.saturating_sub(snap.ts);
        (age, 1)  // TODO: get actual count from DB
    } else {
        (0, 0)
    };

    Ok(serde_json::json!({
        "daemon_state": "running",
        "db_path": "/var/lib/anna/telemetry.db",
        "last_sample_age_s": last_sample_age_s,
        "sample_count": sample_count,
        "loop_load_pct": 0.4,  // TODO: calculate actual
        "annad_pid": std::process::id()
    }))
}

async fn method_sensors(&self, _params: &Option<Value>) -> Result<Value> {
    let storage = self.storage.lock().await;
    let snapshot = storage.get_latest_snapshot()
        .context("No telemetry data available")?;

    Ok(serde_json::json!({
        "cpu": {
            "cores": snapshot.cpu.cores,
            "load_avg": snapshot.cpu.load_avg
        },
        "mem": snapshot.mem,
        "power": snapshot.power
    }))
}

async fn method_net(&self, _params: &Option<Value>) -> Result<Value> {
    let storage = self.storage.lock().await;
    let snapshot = storage.get_latest_snapshot()
        .context("No telemetry data available")?;

    Ok(serde_json::json!({
        "interfaces": snapshot.net,
        "default_route": "auto"  // TODO: detect actual route
    }))
}

async fn method_disk(&self, _params: &Option<Value>) -> Result<Value> {
    let storage = self.storage.lock().await;
    let snapshot = storage.get_latest_snapshot()
        .context("No telemetry data available")?;

    Ok(serde_json::json!({
        "disks": snapshot.disk
    }))
}

async fn method_top(&self, _params: &Option<Value>) -> Result<Value> {
    let storage = self.storage.lock().await;
    let snapshot = storage.get_latest_snapshot()
        .context("No telemetry data available")?;

    let mut by_cpu = snapshot.processes.clone();
    by_cpu.sort_by(|a, b| b.cpu_pct.partial_cmp(&a.cpu_pct).unwrap());
    by_cpu.truncate(5);

    let mut by_mem = snapshot.processes.clone();
    by_mem.sort_by(|a, b| b.mem_mb.partial_cmp(&a.mem_mb).unwrap());
    by_mem.truncate(5);

    Ok(serde_json::json!({
        "by_cpu": by_cpu,
        "by_mem": by_mem
    }))
}

async fn method_radar(&self, _params: &Option<Value>) -> Result<Value> {
    let storage = self.storage.lock().await;
    let scores = storage.query_latest_persona_scores()?;

    let personas: Vec<Value> = scores.into_iter().map(|(name, score, evidence)| {
        serde_json::json!({
            "name": name,
            "score": score,
            "evidence": evidence
        })
    }).collect();

    Ok(serde_json::json!({
        "personas": personas
    }))
}

async fn method_export(&self, _params: &Option<Value>) -> Result<Value> {
    let storage = self.storage.lock().await;
    let snapshot = storage.get_latest_snapshot()
        .context("No telemetry data available")?;
    let scores = storage.query_latest_persona_scores()?;

    Ok(serde_json::json!({
        "snapshot": snapshot,
        "persona_scores": scores,
        "exported_at": SystemTime::now().duration_since(UNIX_EPOCH)?.as_secs()
    }))
}
```

Update the method dispatcher to use these names:

```rust
let result = match req.method.as_str() {
    "status" => self.method_status(&req.params).await,
    "sensors" => self.method_sensors(&req.params).await,
    "net" => self.method_net(&req.params).await,
    "disk" => self.method_disk(&req.params).await,
    "top" => self.method_top(&req.params).await,
    "radar" => self.method_radar(&req.params).await,
    "export" => self.method_export(&req.params).await,
    _ => { /* method not found */ }
};
```

### Step 2: Replace annactl/src/main.rs

Move old main.rs to attic and replace with:

```bash
mv src/annactl/src/main.rs attic/annactl_main_old.rs
mv src/annactl/src/main_v10.rs src/annactl/src/main.rs
```

### Step 3: Update annad to use v10 main

```bash
# The daemon main is already using v10 modules
# Verify it's correctly set as the binary entry point
```

### Step 4: Create Systemd Unit

Create `/etc/systemd/system/annad.service`:

```ini
[Unit]
Description=Anna v0.10.1 Pure Telemetry Observer Daemon
Documentation=https://github.com/anna-assistant/anna
After=network.target

[Service]
Type=simple
User=anna
Group=anna
ExecStart=/usr/local/bin/annad
Restart=on-failure
RestartSec=10
CPUQuota=5%
MemoryMax=80M
RuntimeDirectory=anna
RuntimeDirectoryMode=0750

# Security hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/lib/anna /var/log/anna
CapabilityBoundingSet=

[Install]
WantedBy=multi-user.target
```

### Step 5: Create 6-Phase Installer

Create `scripts/install_v10.sh`:

```bash
#!/bin/bash
# Anna v0.10.1 Pure Observer Installer
# 6 phases: Detect, Prepare, Install, Configure, Verify, Celebrate

set -e

# Color codes for pretty output
C_RESET="\e[0m"
C_BLUE="\e[34m"
C_GREEN="\e[32m"
C_YELLOW="\e[33m"
C_RED="\e[31m"

# Unicode box drawing
BOX_TL="â•­"
BOX_TR="â•®"
BOX_BL="â•°"
BOX_BR="â•¯"
BOX_H="â”€"
BOX_V="â”‚"

phase_header() {
    local phase=$1
    local title=$2

    echo -e "\n${C_BLUE}${BOX_TL}${BOX_H} Phase ${phase}/6: ${title} ${BOX_H}${BOX_TR}${C_RESET}"
}

phase_footer() {
    echo -e "${C_BLUE}${BOX_BL}$(printf 'â”€%.0s' {1..50})${BOX_BR}${C_RESET}\n"
}

info() {
    echo -e "${C_BLUE}  â³${C_RESET} $1"
}

success() {
    echo -e "${C_GREEN}  âœ“${C_RESET} $1"
}

warning() {
    echo -e "${C_YELLOW}  âš ${C_RESET} $1"
}

error() {
    echo -e "${C_RED}  âœ—${C_RESET} $1"
}

# Check root
if [[ $EUID -ne 0 ]]; then
    error "This installer must be run as root"
    echo "  Try: sudo $0"
    exit 1
fi

# Phase 1: Detection
phase_header 1 "System Detection"

if ! command -v systemctl &>/dev/null; then
    error "systemd not found (required)"
    exit 1
fi
success "systemd found"

if ! grep -q "Arch Linux" /etc/os-release 2>/dev/null; then
    warning "Not Arch Linux (best effort support)"
else
    success "Arch Linux detected"
fi

if command -v cargo &>/dev/null; then
    success "cargo found"
else
    error "cargo not found - install rust toolchain"
    exit 1
fi

phase_footer

# Phase 2: Preparation
phase_header 2 "Build Preparation"

info "Building release binaries..."
cargo build --release

if [[ ! -f target/release/annad ]] || [[ ! -f target/release/annactl ]]; then
    error "Build failed"
    exit 1
fi

success "Binaries built successfully"
phase_footer

# Phase 3: Installation
phase_header 3 "System Installation"

# Create anna user
if ! id anna &>/dev/null; then
    info "Creating anna system user..."
    useradd -r -s /bin/false -d /var/lib/anna anna
    success "User created"
else
    success "User exists"
fi

# Create directories
info "Creating directories..."
mkdir -p /var/lib/anna
mkdir -p /var/log/anna
mkdir -p /usr/local/bin
chown anna:anna /var/lib/anna /var/log/anna
chmod 0750 /var/lib/anna /var/log/anna
success "Directories created"

# Install binaries
info "Installing binaries..."
install -m 0755 target/release/annad /usr/local/bin/
install -m 0755 target/release/annactl /usr/local/bin/
success "Binaries installed"

phase_footer

# Phase 4: Configuration
phase_header 4 "System Configuration"

# Install systemd unit
info "Installing systemd unit..."
cat > /etc/systemd/system/annad.service <<'EOF'
[Unit]
Description=Anna v0.10.1 Pure Telemetry Observer Daemon
After=network.target

[Service]
Type=simple
User=anna
Group=anna
ExecStart=/usr/local/bin/annad
Restart=on-failure
RestartSec=10
CPUQuota=5%
MemoryMax=80M
RuntimeDirectory=anna
RuntimeDirectoryMode=0750

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
success "Systemd unit installed"

# Enable and start
info "Enabling and starting daemon..."
systemctl enable annad
systemctl start annad
success "Daemon started"

phase_footer

# Phase 5: Verification
phase_header 5 "Health Verification"

info "Waiting for first telemetry sample..."
sleep 35

if systemctl is-active --quiet annad; then
    success "Daemon is running"
else
    error "Daemon failed to start"
    systemctl status annad
    exit 1
fi

# Test RPC
if timeout 5 /usr/local/bin/annactl version &>/dev/null; then
    success "RPC communication OK"
else
    warning "RPC test failed (may need time to stabilize)"
fi

phase_footer

# Phase 6: Celebrate!
phase_header 6 "Installation Complete"

cat <<'BANNER'
  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
  â”‚                                            â”‚
  â”‚     Anna is ready to observe! ğŸ¤–           â”‚
  â”‚                                            â”‚
  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

  Next steps:

    annactl status      # View daemon status
    annactl sensors     # CPU, memory, temps
    annactl net         # Network interfaces
    annactl disk        # Disk usage
    annactl top         # Top processes
    annactl radar       # Persona classification

  Logs:
    journalctl -u annad -f

  Database:
    /var/lib/anna/telemetry.db

BANNER

phase_footer

echo -e "${C_GREEN}Installation successful!${C_RESET}\n"
```

### Step 6: Create Uninstaller

Create `scripts/uninstall_v10.sh`:

```bash
#!/bin/bash
# Anna v0.10.1 Uninstaller

set -e

PURGE=false

if [[ "$1" == "--purge" ]]; then
    PURGE=true
fi

echo "Uninstalling Anna v0.10.1..."

# Stop and disable service
if systemctl is-active annad &>/dev/null; then
    echo "  Stopping daemon..."
    systemctl stop annad
fi

if systemctl is-enabled annad &>/dev/null; then
    echo "  Disabling service..."
    systemctl disable annad
fi

# Remove systemd unit
if [[ -f /etc/systemd/system/annad.service ]]; then
    echo "  Removing systemd unit..."
    rm /etc/systemd/system/annad.service
    systemctl daemon-reload
fi

# Remove binaries
if [[ -f /usr/local/bin/annad ]]; then
    echo "  Removing daemon binary..."
    rm /usr/local/bin/annad
fi

if [[ -f /usr/local/bin/annactl ]]; then
    echo "  Removing CLI binary..."
    rm /usr/local/bin/annactl
fi

# Remove runtime dir
if [[ -d /run/anna ]]; then
    echo "  Removing runtime directory..."
    rm -rf /run/anna
fi

if [[ "$PURGE" == "true" ]]; then
    echo "  Purging data and logs..."
    rm -rf /var/lib/anna
    rm -rf /var/log/anna

    if id anna &>/dev/null; then
        echo "  Removing anna user..."
        userdel anna
    fi

    echo "âœ“ Complete uninstall (data purged)"
else
    echo "âœ“ Uninstalled (data preserved in /var/lib/anna)"
    echo "  To remove all data, run: $0 --purge"
fi
```

### Step 7: Create Makefile

```makefile
.PHONY: build install uninstall clean test fmt lint smoke

build:
	cargo build --release

install: build
	sudo ./scripts/install_v10.sh

uninstall:
	sudo ./scripts/uninstall_v10.sh

clean:
	cargo clean

test:
	cargo test --all

fmt:
	cargo fmt --all

lint:
	cargo clippy --all-targets -- -D warnings

smoke: install
	sleep 35
	annactl version
	annactl status
	annactl sensors
	annactl net
	annactl disk
	annactl top
	annactl radar
```

## Validation Checklist

### Functional Tests
- [ ] `cargo build --release` succeeds with 0 errors, 0 warnings
- [ ] `sudo ./scripts/install_v10.sh` completes all 6 phases
- [ ] `systemctl status annad` shows active (running)
- [ ] `annactl version` prints version
- [ ] `annactl status` shows daemon stats
- [ ] `annactl sensors` shows CPU, memory, temps
- [ ] `annactl net` shows network interfaces
- [ ] `annactl disk` shows filesystem usage
- [ ] `annactl top` shows top 5 processes
- [ ] `annactl radar` shows 8 persona scores
- [ ] `annactl export --output /tmp/test.json` creates JSON file
- [ ] Database exists at `/var/lib/anna/telemetry.db`
- [ ] Database contains at least 2 samples after 90 seconds

### Performance Tests
- [ ] `htop` shows annad using < 0.5% CPU (idle system)
- [ ] `ps aux | grep annad` shows RSS < 60 MB
- [ ] Telemetry loop runs every 30Â±5 seconds (check logs)

### Security Tests
- [ ] annad runs as `anna` user (not root)
- [ ] Socket `/run/anna/annad.sock` has 0660 permissions
- [ ] Database `/var/lib/anna/telemetry.db` owned by anna:anna
- [ ] No secrets in database (check IP redaction, MAC hashing)

## Documentation to Write

1. **docs/V010_ARCHITECTURE.md** - 1-page architecture diagram
2. **docs/CLI.md** - Examples of all 7 commands with screenshots
3. **docs/INSTALL.md** - Installation guide
4. **docs/UNINSTALL.md** - Uninstallation guide

## Estimated Completion Time

- RPC handlers: 2 hours
- CLI integration: 30 minutes
- Installer/uninstaller: 2 hours
- Testing and validation: 1 hour
- Documentation: 1 hour

**Total: ~6.5 hours**

## Known Limitations

1. No log rotation (logs grow unbounded)
2. IPv4/IPv6 parsing not implemented (shows None)
3. SMART disk health not implemented
4. WiFi RSSI/SSID not collected
5. Systemd unit states not collected
6. No remote backup support

These can be addressed in v0.10.2+
