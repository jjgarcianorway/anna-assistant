# Anna v1.2 Phase 2+ Design Specification

> **Status**: Design Document (Implementation Pending)
>
> **Goal**: Extend Anna's autonomous capabilities with state snapshots, extended advisor rules, behavioral awareness, and comprehensive testing while maintaining her calm, elegant, and safe design philosophy.

---

## Phase 2: State Snapshots

### Overview

State snapshots provide true rollback capability by capturing system state before and after autonomous actions. This enables not just command reversal, but complete state restoration.

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Apply Action                              â”‚
â”‚  1. Capture "before" snapshot                               â”‚
â”‚  2. Execute command                                         â”‚
â”‚  3. Capture "after" snapshot                                â”‚
â”‚  4. Create rollback token with snapshots                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚
                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Rollback with Restoration                      â”‚
â”‚  1. Load rollback token with snapshots                      â”‚
â”‚  2. Compare current state vs "before" snapshot              â”‚
â”‚  3. Generate restoration plan                               â”‚
â”‚  4. Execute restoration                                     â”‚
â”‚  5. Verify state matches "before" snapshot                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Structures

```rust
/// Complete system state snapshot
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StateSnapshot {
    pub timestamp: u64,
    pub packages: PackageSnapshot,
    pub files: FileSnapshot,
    pub services: ServiceSnapshot,
}

/// Package state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageSnapshot {
    pub installed: Vec<PackageInfo>,
    pub checksum: String,  // SHA-256 of sorted package list
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PackageInfo {
    pub name: String,
    pub version: String,
    pub installed_size: u64,
}

/// File modifications
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileSnapshot {
    pub modified_files: Vec<FileInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileInfo {
    pub path: String,
    pub checksum: String,  // SHA-256
    pub mode: u32,         // File permissions
    pub backup_path: Option<String>,  // Backup location if modified
}

/// Service state
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceSnapshot {
    pub services: Vec<ServiceInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInfo {
    pub name: String,
    pub active: bool,
    pub enabled: bool,
}
```

### Implementation Plan

#### 2.1 Snapshot Capture Module (`state_snapshot.rs`)

```rust
pub struct SnapshotEngine {
    snapshot_dir: PathBuf,
}

impl SnapshotEngine {
    /// Capture current system state
    pub fn capture_snapshot(&self) -> Result<StateSnapshot> {
        Ok(StateSnapshot {
            timestamp: SystemTime::now()
                .duration_since(UNIX_EPOCH)?
                .as_secs(),
            packages: self.capture_packages()?,
            files: self.capture_files()?,
            services: self.capture_services()?,
        })
    }

    /// Capture package state via pacman
    fn capture_packages(&self) -> Result<PackageSnapshot> {
        let output = Command::new("pacman")
            .args(&["-Q"])
            .output()?;

        let installed = parse_pacman_output(&output.stdout)?;
        let checksum = calculate_checksum(&installed);

        Ok(PackageSnapshot { installed, checksum })
    }

    /// Capture file modifications
    fn capture_files(&self) -> Result<FileSnapshot> {
        // Track files in common config locations
        let watch_paths = vec![
            "/etc/pacman.conf",
            "/etc/makepkg.conf",
            "/etc/locale.gen",
            "/etc/fstab",
            "/boot/grub/grub.cfg",
        ];

        let mut modified_files = Vec::new();

        for path in watch_paths {
            if let Ok(info) = self.capture_file_info(path) {
                modified_files.push(info);
            }
        }

        Ok(FileSnapshot { modified_files })
    }

    /// Capture individual file state
    fn capture_file_info(&self, path: &str) -> Result<FileInfo> {
        let metadata = fs::metadata(path)?;
        let contents = fs::read(path)?;
        let checksum = sha256_hash(&contents);

        // Create backup
        let backup_path = self.create_backup(path, &contents)?;

        Ok(FileInfo {
            path: path.to_string(),
            checksum,
            mode: metadata.permissions().mode(),
            backup_path: Some(backup_path),
        })
    }

    /// Capture service state via systemctl
    fn capture_services(&self) -> Result<ServiceSnapshot> {
        let services = vec![
            "sshd",
            "NetworkManager",
            "bluetooth",
            "cups",
        ];

        let mut service_states = Vec::new();

        for service in services {
            if let Ok(info) = self.capture_service_info(service) {
                service_states.push(info);
            }
        }

        Ok(ServiceSnapshot { services: service_states })
    }

    /// Save snapshot to disk
    pub fn save_snapshot(&self, snapshot: &StateSnapshot, id: &str) -> Result<PathBuf> {
        let filename = format!("{}_{}.json", id, snapshot.timestamp);
        let path = self.snapshot_dir.join(filename);

        let json = serde_json::to_string_pretty(snapshot)?;
        fs::write(&path, json)?;

        Ok(path)
    }
}
```

#### 2.2 Integration with Apply Command

**Modify `apply_cmd.rs`**:

```rust
async fn execute_advice(advice: &Advice) -> Result<RollbackToken> {
    // NEW: Create snapshot engine
    let snapshot_engine = SnapshotEngine::new()?;

    // NEW: Capture BEFORE state
    let before_snapshot = snapshot_engine.capture_snapshot()
        .context("Failed to capture before snapshot")?;

    // Execute command (existing code)
    let output = Command::new("sh")
        .arg("-c")
        .arg(cmd)
        .output()?;

    let success = output.status.success();

    // NEW: Capture AFTER state (only if successful)
    let after_snapshot = if success {
        Some(snapshot_engine.capture_snapshot()
            .context("Failed to capture after snapshot")?)
    } else {
        None
    };

    // Create rollback token with snapshots
    let token = RollbackToken {
        advice_id: advice.id.clone(),
        executed_at: now,
        command: cmd.clone(),
        success,
        output: output_str,
        state_snapshot: Some(StateSnapshotPair {
            before: before_snapshot,
            after: after_snapshot,
        }),
    };

    Ok(token)
}
```

#### 2.3 State Restoration in Rollback

**Modify `rollback_cmd.rs`**:

```rust
fn perform_rollback(token: &RollbackToken) -> Result<()> {
    if let Some(ref snapshot_pair) = token.state_snapshot {
        // Use snapshot-based restoration
        restore_from_snapshot(&snapshot_pair.before, &snapshot_pair.after)?;
    } else {
        // Fallback to command-based rollback (existing code)
        let rollback_cmd = create_rollback_command(&token.command, &None)?;
        execute_rollback_command(&rollback_cmd)?;
    }

    Ok(())
}

fn restore_from_snapshot(
    before: &StateSnapshot,
    after: &Option<StateSnapshot>,
) -> Result<()> {
    println!("Restoring system state...");

    // 1. Restore packages
    restore_packages(&before.packages, after.as_ref().map(|s| &s.packages))?;

    // 2. Restore files
    restore_files(&before.files)?;

    // 3. Restore services
    restore_services(&before.services)?;

    Ok(())
}

fn restore_packages(
    before: &PackageSnapshot,
    after: Option<&PackageSnapshot>,
) -> Result<()> {
    if let Some(after) = after {
        // Find packages added during action
        let added: Vec<_> = after.installed.iter()
            .filter(|p| !before.installed.contains(p))
            .collect();

        if !added.is_empty() {
            // Remove added packages
            let package_names: Vec<_> = added.iter()
                .map(|p| p.name.as_str())
                .collect();

            let cmd = format!("sudo pacman -Rns {}", package_names.join(" "));
            execute_command(&cmd)?;
        }
    }

    Ok(())
}

fn restore_files(snapshot: &FileSnapshot) -> Result<()> {
    for file_info in &snapshot.modified_files {
        if let Some(ref backup_path) = file_info.backup_path {
            // Restore from backup
            fs::copy(backup_path, &file_info.path)?;

            // Restore permissions
            let mut perms = fs::metadata(&file_info.path)?.permissions();
            perms.set_mode(file_info.mode);
            fs::set_permissions(&file_info.path, perms)?;
        }
    }

    Ok(())
}
```

### Storage Layout

```
~/.local/state/anna/
â”œâ”€â”€ snapshots/
â”‚   â”œâ”€â”€ microcode-intel-missing_1705334567.json
â”‚   â”œâ”€â”€ orphan-packages_1705334890.json
â”‚   â””â”€â”€ ...
â”œâ”€â”€ backups/
â”‚   â”œâ”€â”€ etc_pacman.conf_1705334567.bak
â”‚   â”œâ”€â”€ boot_grub_grub.cfg_1705334890.bak
â”‚   â””â”€â”€ ...
â”œâ”€â”€ rollback_tokens.jsonl
â””â”€â”€ audit.jsonl
```

### Testing Scenarios

1. **Package Installation/Removal**
   - Apply: Install package â†’ Snapshot captures new package
   - Rollback: Remove package â†’ Verify package removed

2. **File Modification**
   - Apply: Edit config file â†’ Snapshot backs up original
   - Rollback: Restore from backup â†’ Verify checksum matches

3. **Service State Changes**
   - Apply: Enable service â†’ Snapshot records state change
   - Rollback: Disable service â†’ Verify service disabled

---

## Phase 3: Extended Advisor Rules

### New Rule Categories

#### 3.1 Editor Defaults (5 rules)

**Rule: Vim Syntax Highlighting**
```rust
fn check_vim_syntax_highlighting(pkg: &PackageInventory) -> Vec<Advice> {
    let vimrc_path = format!("{}/.vimrc", env::var("HOME").unwrap());

    if !Path::new(&vimrc_path).exists() {
        return vec![Advice {
            id: "vim-syntax-missing".to_string(),
            level: Level::Info,
            category: "editor".to_string(),
            title: "Vim syntax highlighting not enabled".to_string(),
            reason: "No .vimrc found - syntax highlighting disabled by default".to_string(),
            action: "Create .vimrc with syntax highlighting enabled".to_string(),
            explain: Some("Syntax highlighting improves code readability by color-coding language elements. Essential for development work.".to_string()),
            fix_cmd: Some("echo 'syntax on\nset number\nset ruler' > ~/.vimrc".to_string()),
            fix_risk: Some("Low - only creates user config file, no system changes".to_string()),
            refs: vec!["https://wiki.archlinux.org/title/Vim#Configuration".to_string()],
        }];
    }

    vec![]
}
```

**Additional Editor Rules**:
- Git user config missing (`~/.gitconfig`)
- Git editor not set (defaults to vi)
- Nano syntax highlighting disabled
- VS Code settings sync not configured

#### 3.2 System Limits (3 rules)

**Rule: Journald Size Limit**
```rust
fn check_journald_size_limit(pkg: &PackageInventory) -> Vec<Advice> {
    let journald_conf = "/etc/systemd/journald.conf";

    let content = match fs::read_to_string(journald_conf) {
        Ok(c) => c,
        Err(_) => return vec![],
    };

    if !content.contains("SystemMaxUse") || content.contains("#SystemMaxUse") {
        return vec![Advice {
            id: "journald-size-unlimited".to_string(),
            level: Level::Warn,
            category: "system".to_string(),
            title: "Journald log size not limited".to_string(),
            reason: "SystemMaxUse not configured - logs can grow unbounded".to_string(),
            action: "Set SystemMaxUse to reasonable limit (e.g., 500M)".to_string(),
            explain: Some("Unlimited journal logs can consume significant disk space. Setting SystemMaxUse=500M limits journal to 500MB total.".to_string()),
            fix_cmd: Some("sudo sed -i 's/#SystemMaxUse=/SystemMaxUse=500M/' /etc/systemd/journald.conf && sudo systemctl restart systemd-journald".to_string()),
            fix_risk: Some("Low - only limits log size, old logs auto-rotate".to_string()),
            refs: vec!["https://wiki.archlinux.org/title/Systemd/Journal#Journal_size_limit".to_string()],
        }];
    }

    vec![]
}
```

**Additional System Limit Rules**:
- Coredump disabled (`/etc/systemd/coredump.conf`)
- Max user processes limit (`/etc/security/limits.conf`)

#### 3.3 Security Defaults (3 rules)

**Rule: Firewall Status**
```rust
fn check_firewall_status(pkg: &PackageInventory) -> Vec<Advice> {
    let has_ufw = pkg.groups.base.iter().any(|p| p.contains("ufw"));
    let has_firewalld = pkg.groups.base.iter().any(|p| p.contains("firewalld"));

    if !has_ufw && !has_firewalld {
        return vec![Advice {
            id: "firewall-missing".to_string(),
            level: Level::Warn,
            category: "security".to_string(),
            title: "No firewall installed".to_string(),
            reason: "Neither ufw nor firewalld detected".to_string(),
            action: "Install and configure firewall".to_string(),
            explain: Some("A firewall protects your system from unwanted network connections. UFW (Uncomplicated Firewall) is recommended for simplicity.".to_string()),
            fix_cmd: Some("sudo pacman -S ufw && sudo systemctl enable --now ufw && sudo ufw default deny incoming && sudo ufw default allow outgoing && sudo ufw enable".to_string()),
            fix_risk: Some("Medium - may block services if rules not configured. Test SSH access before enabling on remote systems.".to_string()),
            refs: vec!["https://wiki.archlinux.org/title/Uncomplicated_Firewall".to_string()],
        }];
    }

    vec![]
}
```

**Additional Security Rules**:
- SSH password authentication enabled (should use keys)
- Root login via SSH enabled (should be disabled)

#### 3.4 Performance Tuning (2 rules)

**Rule: Swappiness**
```rust
fn check_swappiness(hw: &HardwareProfile) -> Vec<Advice> {
    // Only recommend for systems with >8GB RAM
    if hw.memory.total_gb < 8 {
        return vec![];
    }

    let swappiness = fs::read_to_string("/proc/sys/vm/swappiness")
        .unwrap_or_default()
        .trim()
        .parse::<u32>()
        .unwrap_or(60);

    if swappiness > 10 {
        return vec![Advice {
            id: "swappiness-high".to_string(),
            level: Level::Info,
            category: "performance".to_string(),
            title: "Swappiness set to default (60)".to_string(),
            reason: format!("System has {} GB RAM but swappiness={}", hw.memory.total_gb, swappiness),
            action: "Lower swappiness for better performance".to_string(),
            explain: Some("Swappiness controls how aggressively the kernel swaps memory to disk. Lower values (10) reduce swap usage on systems with sufficient RAM.".to_string()),
            fix_cmd: Some("echo 'vm.swappiness=10' | sudo tee -a /etc/sysctl.d/99-swappiness.conf && sudo sysctl vm.swappiness=10".to_string()),
            fix_risk: Some("Low - only affects swap behavior, can be reverted".to_string()),
            refs: vec!["https://wiki.archlinux.org/title/Swap#Swappiness".to_string()],
        }];
    }

    vec![]
}
```

**Additional Performance Rule**:
- I/O scheduler not optimized for SSD (should use `none` or `mq-deadline`)

### Rule Template

```rust
/// Rule N: Brief description
///
/// Category: system|editor|security|performance|maintenance
/// Risk: Low|Medium|High
/// Wiki: https://wiki.archlinux.org/title/Topic
fn check_rule_name(
    hw: &HardwareProfile,
    pkg: &PackageInventory,
    btrfs: Option<&BtrfsProfile>
) -> Vec<Advice> {
    let mut result = Vec::new();

    // Condition check
    if should_recommend() {
        result.push(Advice {
            id: "rule-id".to_string(),
            level: Level::Info, // or Warn, Error
            category: "category".to_string(),
            title: "Brief title".to_string(),
            reason: "Why this is recommended".to_string(),
            action: "What to do".to_string(),
            explain: Some("Detailed explanation with context".to_string()),
            fix_cmd: Some("command to execute".to_string()),
            fix_risk: Some("Low - explanation of safety".to_string()),
            refs: vec!["https://wiki.archlinux.org/title/Topic".to_string()],
        });
    }

    result
}
```

---

## Phase 4: Behavioral Awareness

### Overview

Behavioral awareness analyzes user activity to personalize recommendations. All analysis is local, ephemeral, and privacy-preserving.

### Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Data Collection (Local Only)                â”‚
â”‚  â€¢ Shell history (.bash_history, .zsh_history)             â”‚
â”‚  â€¢ Process CPU time (ps aux)                                â”‚
â”‚  â€¢ Package usage patterns                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Pattern Detection (In-Memory)                  â”‚
â”‚  â€¢ Classify workflow: dev, server, creative, gaming        â”‚
â”‚  â€¢ Detect primary tools: editors, languages, frameworks    â”‚
â”‚  â€¢ Identify usage frequency: daily, weekly, monthly        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Recommendation Prioritization                     â”‚
â”‚  â€¢ Developer â†’ prioritize editor, git, compiler rules      â”‚
â”‚  â€¢ Server â†’ prioritize security, firewall, monitoring      â”‚
â”‚  â€¢ Creative â†’ prioritize media codecs, fonts, color        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Structures

```rust
/// User workflow profile
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowProfile {
    pub primary_type: WorkflowType,
    pub confidence: f32,  // 0.0 - 1.0
    pub detected_tools: Vec<DetectedTool>,
    pub usage_patterns: UsagePatterns,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WorkflowType {
    Developer { languages: Vec<String> },
    Server { services: Vec<String> },
    Creative { tools: Vec<String> },
    Gaming { launchers: Vec<String> },
    Mixed,
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DetectedTool {
    pub name: String,
    pub category: String,  // "editor", "compiler", "vcs", etc.
    pub frequency: Frequency,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Frequency {
    Daily,
    Weekly,
    Monthly,
    Rare,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UsagePatterns {
    pub active_hours: Vec<u8>,  // 0-23
    pub shell_type: ShellType,
    pub terminal_emulator: Option<String>,
}
```

### Implementation

```rust
pub struct BehavioralAnalyzer {
    // No persistent storage - all in-memory
}

impl BehavioralAnalyzer {
    /// Analyze user behavior and generate workflow profile
    pub fn analyze(&self) -> Result<WorkflowProfile> {
        let history = self.parse_shell_history()?;
        let processes = self.analyze_processes()?;
        let packages = self.analyze_packages()?;

        let workflow = self.classify_workflow(&history, &processes, &packages)?;

        Ok(workflow)
    }

    /// Parse shell history (bash, zsh, fish)
    fn parse_shell_history(&self) -> Result<Vec<HistoryEntry>> {
        let home = env::var("HOME")?;
        let history_files = vec![
            format!("{}/.bash_history", home),
            format!("{}/.zsh_history", home),
            format!("{}/.local/share/fish/fish_history", home),
        ];

        let mut entries = Vec::new();

        for file in history_files {
            if let Ok(content) = fs::read_to_string(&file) {
                entries.extend(self.parse_history_file(&content));
            }
        }

        Ok(entries)
    }

    /// Classify workflow based on evidence
    fn classify_workflow(
        &self,
        history: &[HistoryEntry],
        processes: &[ProcessInfo],
        packages: &[String],
    ) -> Result<WorkflowProfile> {
        let dev_score = self.score_developer(history, packages);
        let server_score = self.score_server(processes, packages);
        let creative_score = self.score_creative(history, packages);

        let (primary_type, confidence) = if dev_score > server_score && dev_score > creative_score {
            (
                WorkflowType::Developer {
                    languages: self.detect_languages(history),
                },
                dev_score,
            )
        } else if server_score > creative_score {
            (
                WorkflowType::Server {
                    services: self.detect_services(processes),
                },
                server_score,
            )
        } else if creative_score > 0.3 {
            (
                WorkflowType::Creative {
                    tools: self.detect_creative_tools(packages),
                },
                creative_score,
            )
        } else {
            (WorkflowType::Unknown, 0.0)
        };

        Ok(WorkflowProfile {
            primary_type,
            confidence,
            detected_tools: self.detect_tools(history, packages),
            usage_patterns: self.analyze_usage_patterns(history),
        })
    }

    /// Score developer likelihood
    fn score_developer(&self, history: &[HistoryEntry], packages: &[String]) -> f32 {
        let dev_commands = ["git", "cargo", "npm", "python", "gcc", "make", "vim", "code"];
        let dev_packages = ["git", "base-devel", "python", "rust", "go", "nodejs"];

        let command_score = history.iter()
            .filter(|e| dev_commands.iter().any(|cmd| e.command.contains(cmd)))
            .count() as f32 / history.len().max(1) as f32;

        let package_score = packages.iter()
            .filter(|p| dev_packages.iter().any(|dp| p.contains(dp)))
            .count() as f32 / packages.len().max(1) as f32;

        (command_score * 0.7 + package_score * 0.3).min(1.0)
    }
}
```

### Privacy Guarantees

1. **No Persistent Storage**: Behavioral analysis runs in-memory only
2. **No Network Transmission**: All data stays local
3. **User Control**: Feature can be disabled via config
4. **Transparency**: Show user exactly what was detected

### Integration with Advisor

```rust
impl ArchAdvisor {
    pub fn run_with_behavior(
        hw: &HardwareProfile,
        pkg: &PackageInventory,
        btrfs: Option<&BtrfsProfile>,
        behavior: Option<&WorkflowProfile>,
    ) -> Vec<Advice> {
        let mut advice = Self::run(hw, pkg, btrfs);

        // Prioritize based on workflow
        if let Some(profile) = behavior {
            advice = Self::prioritize_by_workflow(advice, profile);
        }

        advice
    }

    fn prioritize_by_workflow(
        mut advice: Vec<Advice>,
        profile: &WorkflowProfile,
    ) -> Vec<Advice> {
        match &profile.primary_type {
            WorkflowType::Developer { .. } => {
                // Boost editor, git, compiler rules
                advice.sort_by(|a, b| {
                    let a_score = Self::developer_relevance_score(a);
                    let b_score = Self::developer_relevance_score(b);
                    b_score.partial_cmp(&a_score).unwrap()
                });
            }
            WorkflowType::Server { .. } => {
                // Boost security, firewall, monitoring rules
                advice.sort_by(|a, b| {
                    let a_score = Self::server_relevance_score(a);
                    let b_score = Self::server_relevance_score(b);
                    b_score.partial_cmp(&a_score).unwrap()
                });
            }
            _ => {}
        }

        advice
    }
}
```

---

## Phase 5: Automated Testing

### Test Structure

```
tests/
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ apply_tests.rs          # Unit tests for apply command
â”‚   â”œâ”€â”€ rollback_tests.rs       # Unit tests for rollback command
â”‚   â”œâ”€â”€ advisor_tests.rs        # Unit tests for advisor rules
â”‚   â””â”€â”€ snapshot_tests.rs       # Unit tests for state snapshots
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ apply_rollback_cycle.rs # End-to-end apply â†’ rollback
â”‚   â”œâ”€â”€ advisor_execution.rs    # Advisor â†’ apply integration
â”‚   â””â”€â”€ snapshot_restoration.rs # Snapshot â†’ restore integration
â””â”€â”€ e2e/
    â”œâ”€â”€ full_workflow.rs        # Complete user workflow
    â””â”€â”€ error_scenarios.rs      # Error handling and recovery
```

### Unit Tests

#### Apply Command Tests

```rust
#[cfg(test)]
mod apply_tests {
    use super::*;

    #[test]
    fn test_filter_low_risk_actions() {
        let advice = vec![
            create_test_advice("low-risk", "Low - safe"),
            create_test_advice("medium-risk", "Medium - requires review"),
            create_test_advice("high-risk", "High - dangerous"),
        ];

        let low_risk = filter_low_risk(&advice);

        assert_eq!(low_risk.len(), 1);
        assert_eq!(low_risk[0].id, "low-risk");
    }

    #[test]
    fn test_rollback_token_generation() {
        let advice = create_test_advice("test", "Low");
        let token = create_rollback_token(&advice, true, "output").unwrap();

        assert_eq!(token.advice_id, "test");
        assert!(token.success);
        assert!(token.executed_at > 0);
    }

    #[test]
    fn test_dry_run_no_execution() {
        let advice = create_test_advice("test", "Low");
        let result = execute_advice_dry_run(&advice).unwrap();

        assert!(result.contains("Would execute"));
        // Verify no actual execution occurred
    }
}
```

#### Rollback Command Tests

```rust
#[cfg(test)]
mod rollback_tests {
    use super::*;

    #[test]
    fn test_load_rollback_tokens() {
        setup_test_tokens();

        let tokens = load_rollback_tokens().unwrap();

        assert_eq!(tokens.len(), 3);
        assert!(tokens.iter().any(|t| t.advice_id == "test-1"));
    }

    #[test]
    fn test_rollback_strategy_detection() {
        let strategies = vec![
            ("sudo pacman -S package", "Remove installed packages"),
            ("sudo pacman -Sy", "âš ï¸  Database updates cannot be rolled back"),
            ("systemctl restart service", "Restart service to previous state"),
        ];

        for (cmd, expected) in strategies {
            let strategy = determine_rollback_strategy(cmd);
            assert_eq!(strategy, expected);
        }
    }

    #[test]
    fn test_package_extraction() {
        let cmd = "sudo pacman -S intel-ucode amd-ucode";
        let packages = extract_packages_from_pacman(cmd);

        assert_eq!(packages, vec!["intel-ucode", "amd-ucode"]);
    }
}
```

#### State Snapshot Tests

```rust
#[cfg(test)]
mod snapshot_tests {
    use super::*;

    #[test]
    fn test_package_snapshot_capture() {
        let engine = SnapshotEngine::new().unwrap();
        let snapshot = engine.capture_packages().unwrap();

        assert!(!snapshot.installed.is_empty());
        assert!(!snapshot.checksum.is_empty());
    }

    #[test]
    fn test_file_backup_creation() {
        let engine = SnapshotEngine::new().unwrap();
        let test_file = "/tmp/test_config.txt";

        fs::write(test_file, "original content").unwrap();

        let file_info = engine.capture_file_info(test_file).unwrap();

        assert!(file_info.backup_path.is_some());
        assert_eq!(
            fs::read_to_string(file_info.backup_path.unwrap()).unwrap(),
            "original content"
        );
    }

    #[test]
    fn test_snapshot_serialization() {
        let snapshot = create_test_snapshot();
        let json = serde_json::to_string(&snapshot).unwrap();
        let deserialized: StateSnapshot = serde_json::from_str(&json).unwrap();

        assert_eq!(snapshot.timestamp, deserialized.timestamp);
        assert_eq!(snapshot.packages.checksum, deserialized.packages.checksum);
    }
}
```

### Integration Tests

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;

    #[tokio::test]
    async fn test_apply_rollback_cycle() {
        // Setup test environment
        setup_test_daemon();
        setup_test_packages();

        // 1. Get advisor recommendations
        let advice = fetch_advisor_results().await.unwrap();
        assert!(!advice.is_empty());

        // 2. Apply low-risk action
        let mode = ApplyMode::Specific("test-action".to_string());
        apply_cmd::run_apply(mode, false, true).await.unwrap();

        // 3. Verify rollback token created
        let tokens = load_rollback_tokens().unwrap();
        assert!(tokens.iter().any(|t| t.advice_id == "test-action"));

        // 4. Rollback action
        let mode = RollbackMode::Last;
        rollback_cmd::run_rollback(mode, false).unwrap();

        // 5. Verify token removed
        let tokens = load_rollback_tokens().unwrap();
        assert!(!tokens.iter().any(|t| t.advice_id == "test-action"));
    }

    #[tokio::test]
    async fn test_snapshot_restoration() {
        let engine = SnapshotEngine::new().unwrap();

        // Capture before state
        let before = engine.capture_snapshot().unwrap();

        // Simulate system change
        simulate_package_install("test-package");

        // Capture after state
        let after = engine.capture_snapshot().unwrap();

        // Verify difference detected
        assert_ne!(before.packages.checksum, after.packages.checksum);

        // Restore to before state
        restore_from_snapshot(&before, &Some(after)).unwrap();

        // Verify restoration
        let current = engine.capture_snapshot().unwrap();
        assert_eq!(before.packages.checksum, current.packages.checksum);
    }
}
```

### End-to-End Tests

```rust
#[cfg(test)]
mod e2e_tests {
    use super::*;

    #[tokio::test]
    async fn test_full_autonomous_workflow() {
        // Complete workflow: advisor â†’ apply â†’ verify â†’ rollback

        // 1. Start daemon
        start_daemon().await;

        // 2. Run advisor
        let output = run_command("./annactl advisor --json").await.unwrap();
        let advice: Vec<Advice> = serde_json::from_str(&output).unwrap();

        // 3. Apply first low-risk recommendation
        let low_risk = advice.iter()
            .find(|a| a.fix_risk.as_ref().unwrap().contains("Low"))
            .expect("No low-risk advice found");

        run_command(&format!("./annactl apply --id {} --yes", low_risk.id))
            .await
            .unwrap();

        // 4. Verify action applied
        verify_action_applied(&low_risk.id).await;

        // 5. Check audit log
        let audit = load_audit_log().unwrap();
        assert!(audit.iter().any(|e| e.action_id == low_risk.id));

        // 6. Rollback
        run_command("./annactl rollback --last --yes").await.unwrap();

        // 7. Verify rollback completed
        verify_action_rolled_back(&low_risk.id).await;

        // Cleanup
        stop_daemon().await;
    }
}
```

### Continuous Integration

```yaml
# .github/workflows/test.yml
name: Anna Test Suite

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest

    steps:
      - uses: actions/checkout@v3

      - name: Install dependencies
        run: |
          pacman -Syu --noconfirm
          pacman -S --noconfirm rust cargo systemd

      - name: Run unit tests
        run: cargo test --lib

      - name: Run integration tests
        run: cargo test --test '*'

      - name: Run clippy
        run: cargo clippy -- -D warnings

      - name: Check formatting
        run: cargo fmt -- --check

      - name: Build release
        run: cargo build --release

      - name: Run smoke tests
        run: ./tests/smoke_v101.sh
```

---

## Documentation Updates

### CHANGELOG.md

```markdown
## [1.2.0] - 2024-01-20

### Added
- **Rollback System**
  - `annactl rollback --last` to undo most recent action
  - `annactl rollback --id <advice_id>` to undo specific action
  - `annactl rollback --list` to show rollback history
  - Intelligent rollback strategy detection
  - Audit logging for all rollback operations

- **State Snapshots**
  - Package state capture (before/after)
  - File modification tracking with backups
  - Service state monitoring
  - True state restoration in rollback

- **Extended Advisor Rules** (13 new rules)
  - Editor defaults (vim, git config, nano)
  - System limits (journald, coredump)
  - Security defaults (firewall, SSH hardening)
  - Performance tuning (swappiness, I/O scheduler)

- **Behavioral Awareness**
  - Shell history parsing (bash, zsh, fish)
  - Workflow classification (developer, server, creative)
  - Personalized recommendation prioritization
  - Privacy-first design (all data local)

- **Documentation**
  - CONTRIBUTING.md with development guidelines
  - ROADMAP.md with long-term vision
  - V1.2-PHASE-2-DESIGN.md with technical specifications

### Changed
- Apply command now captures state snapshots
- Rollback uses snapshots when available
- Advisor rules prioritized by user workflow

### Fixed
- Rollback token cleanup on successful rollback
- State snapshot serialization edge cases
```

### README.md Update

```markdown
# Anna â€” Your Calm, Local System Companion

Anna is an intelligent, autonomous system assistant for Arch Linux that provides:

- ğŸ§  **Smart Recommendations** â€” 30+ rules with Arch Wiki citations
- ğŸ¤– **Safe Autonomy** â€” Low-risk actions with rollback support
- ğŸ“Š **Deep Awareness** â€” Hardware, software, and behavioral analysis
- ğŸ”„ **Complete Rollback** â€” Undo any action with state restoration
- ğŸ¨ **Beautiful Output** â€” Calm, elegant, pastel aesthetics

## Quick Start

```bash
# Get system recommendations
annactl advisor

# Apply low-risk improvements automatically
annactl apply --auto --yes

# Undo last action if needed
annactl rollback --last

# Check system health
annactl doctor check

# Generate health report
annactl report
```

## Features

### Autonomous Actions with Rollback

Anna can safely apply system improvements and roll them back if needed:

```bash
$ annactl apply --auto
Found 3 low-risk recommendations:
  â€¢ Intel microcode not installed
  â€¢ Journald size not limited
  â€¢ Vim syntax highlighting disabled

âœ“ Applied: 3
âœ— Failed:  0

$ annactl rollback --list
1. âœ“ microcode-intel-missing â€” 2 minutes ago
2. âœ“ journald-size-unlimited â€” 2 minutes ago
3. âœ“ vim-syntax-missing â€” 2 minutes ago

$ annactl rollback --last
Rollback successful
```

### State Snapshots

Every action creates before/after snapshots:

- Package lists
- File modifications
- Service states
- Configuration backups

### Behavioral Awareness

Anna learns your workflow and prioritizes relevant recommendations:

- **Developer**: Editor configs, git setup, build tools
- **Server**: Security hardening, firewall, monitoring
- **Creative**: Media codecs, color management, fonts

All analysis is local â€” no data leaves your machine.

## Documentation

- [Architecture](docs/ARCHITECTURE.md) â€” System design
- [Contributing](CONTRIBUTING.md) â€” Development guide
- [Roadmap](docs/ROADMAP.md) â€” Future plans

## License

[Your License Here]
```

---

## Implementation Priority

### Phase 2 (State Snapshots) â€” Priority: HIGH
- **Week 1**: Implement snapshot capture (packages, files, services)
- **Week 2**: Integrate with apply command
- **Week 3**: Update rollback for snapshot restoration
- **Week 4**: Testing and validation

### Phase 3 (Extended Rules) â€” Priority: MEDIUM
- **Week 1**: Editor defaults (5 rules)
- **Week 2**: System limits (3 rules)
- **Week 3**: Security defaults (3 rules)
- **Week 4**: Performance tuning (2 rules)

### Phase 4 (Behavioral Awareness) â€” Priority: LOW
- **Week 1**: Shell history parsing
- **Week 2**: Workflow classification
- **Week 3**: Advisor prioritization
- **Week 4**: Privacy review and docs

### Phase 5 (Testing) â€” Priority: HIGH (Ongoing)
- Parallel with all phases
- Unit tests for each feature
- Integration tests for workflows
- CI/CD pipeline setup

---

## Success Metrics

### Rollback System
- âœ… All applied actions can be rolled back
- âœ… Rollback success rate > 95%
- âœ… State snapshots < 1MB each
- âœ… Rollback time < 5 seconds

### Extended Rules
- âœ… 30+ total advisor rules
- âœ… All rules have Wiki citations
- âœ… 80% low-risk rules (safe for auto-apply)
- âœ… User acceptance rate > 70%

### Behavioral Awareness
- âœ… Workflow detection accuracy > 80%
- âœ… Zero privacy violations
- âœ… Analysis time < 100ms
- âœ… User satisfaction with prioritization > 75%

### Testing
- âœ… Code coverage > 80%
- âœ… All tests pass on CI
- âœ… Zero regressions in releases
- âœ… Integration tests cover all workflows

---

**This design specification provides the complete blueprint for Anna v1.2 Phase 2 onwards. Implementation can proceed systematically while maintaining Anna's core principles: beautiful, intelligent, and safe.**
